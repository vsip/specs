<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="math" 
	 xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:m="http://www.w3.org/1998/Math/MathML">
  <title>Mathematical functions and operations</title>

  <titleabbrev>math</titleabbrev>

  <orderedlist>
    <listitem>
      <para>VSIPL++ supports a wide variety of mathematical C++ functions.
      Many of these can be applied to both scalars and views. For example,
      applying sin to a floating point number yields its sine. Applying it to
      a one-dimensional view v yields another one-dimensional view of the same
      size with values equal to the sines of corresponding v values.</para>
    </listitem>

    <listitem>
      <para>&lt;vsip/math.hpp&gt; contains all declarations in this clause
      unless otherwise indicated.</para>
    </listitem>
  </orderedlist>

  <section xml:id="math.enum">
    <title>Enumerations</title>

    <titleabbrev>math.enum</titleabbrev>

    <xi:include href="code/math-enum.hpp"/>

    <orderedlist>
      <listitem>
        <para>[<emphasis>Note: </emphasis> The mat_op_type enumerated value
        mat_ntrans indicates the matrix should not be transposed. mat_trans
        indicates matrix transpose. mat_herm indicates the Hermitian transpose
        or conjugate transpose. mat_conj indicates the complex conjugate of
        matrix entries should occur. ]</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Note: </emphasis> enum <type>product_side_type</type>
        indicates whether to use left or right multiplication in matrix
        products. ]</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Note: </emphasis> enum <type>storage_type</type>
        indicates the storage format for decomposed matrixes. Constants
        appropriate for QR decomposition begin with a qrd prefix. See <xref
        linkend="math.solvers.qr"/> for an explanation of these constants.
        Constants appropriate for singular value decomposition begin with an
        svd prefix. See <xref linkend="math.solvers.svd"/> for an explanation
        of these constants. ]</para>
      </listitem>
    </orderedlist>
  </section>

  <section xml:id="math.definitions">
    <title>Definitions</title>

    <titleabbrev>math.definitions</titleabbrev>

    <orderedlist>
      <listitem>
        <para>A C++ function f on a scalar can be <emphasis>extended
        element-wise</emphasis> to a view by applying f to each value in the
        view. That is, a function f operating on a view v yields another view
        w such that, for all Index&lt;d&gt;es (i1,...,id) in v’s domain, a
        corresponding Index&lt;d&gt; (j1,...,jd) is in w’s domain and
        w(j1,...,jd) == f(v(i1,...,id)) . If val has v::value_type type and
        f(val) is a valid C++ expression and yields a value with type t, then
        w::value_type is t. Element-wise extensions to more than one view are
        analogously defined.</para>
      </listitem>

      <listitem>
        <para>A binary C++ function f on scalars can be <emphasis>extended
        element-wise</emphasis> to a function on a view and a scalar by
        applying f to each pair of a value in the view and the scalar. That
        is, a function f operating on a view v and a scalar s yields another
        view w such that, for all Index&lt;d&gt;es (i1,...,id) in v’s domain,
        a corresponding Index&lt;d&gt; (j1,...,jd) is in w’s domain and
        w(j1,...,jd) = f(v(i1,...,id),s) . If val has v::value_type type and
        f(val,s) is a valid C++ expression and yields a value with type t,
        then w::value_type is t .</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Example: </emphasis> max can be extended element-wise
        to a function on a one-dimensional vector and a scalar. Given a Vector
        v containing the index-value pairs (0,0), (1,4), (2,-2), (3,-20),
        max(v,0) is a Vector containing (0,0), (1,4), (2,0), (3,0) . ]</para>
      </listitem>

      <listitem>
        <para>A binary C++ function f on scalars can be <emphasis>extended
        element-wise</emphasis> to a function on a scalar and a view and is
        defined analogously to the element-wise extension of a binary function
        on a view and a scalar.</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Note: </emphasis> Extending C++ functions to views
        uses the concept of conformance in two different ways. A unary
        function’s element-wise extension yields a view element-conformant to
        its input view if the output view has one value for each input value.
        When a function takes multiple input operands, frequently they must be
        element-conformant. For example, element-wise addition (+) is
        restricted to element-conformant views because these views have
        corresponding values that can be added using the scalar addition
        function. ]</para>
      </listitem>
    </orderedlist>
  </section>

  <section xml:id="math.fns">
    <title>Integral, real, complex, and boolean functions</title>

    <titleabbrev>math.fns</titleabbrev>

    <orderedlist>
      <listitem>
        <para>This subclause defines common mathematical functions on scalars
        and views.</para>

        <xi:include href="code/math-fns.hpp"/>
      </listitem>
    </orderedlist>

    <section xml:id="math.fns.promotions">
      <title>Type Promotions</title>

      <titleabbrev>math.fns.promotions</titleabbrev>

      <orderedlist>
        <listitem>
          <para>The class <type>Promotion</type> implements standard
          arithmetic conversions in (ISO14882, [conv]). [<emphasis>Note:
          </emphasis> When operating on two views containing different value
          types <type>T1</type> and <type>T2</type>, <code>Promotion&lt;T1,
          T2&gt;::type</code> usually yields the resulting view’s value type.
          ] [<emphasis>Example: </emphasis> <code>Promotion&lt;char,
          int&gt;::type</code> is int since adding a <type>char</type> and an
          <type>int</type> yields an <type>int</type> . Promotion is not
          needed when operating on two values with the same type so, for all
          types T, <code>Promotion&lt;T, T&gt;::type</code> is T . ]</para>
        </listitem>

        <listitem>
          <para>An implementation supporting only operations on views
          specialized for particular value types need not define the Promotion
          template class, but all declarations using the template class must
          be equivalent to those if it was defined.</para>
        </listitem>

        <listitem>
          <para>For all ordered pairs <type>T1</type> and <type>T2</type> of
          <type>bool</type>, integral types, and floating types,
          <code>Promotion&lt;T1, T2&gt;::type</code> is the type specified in
          (ISO14882, [conv]).</para>
        </listitem>

        <listitem>
          <para>For all types <type>T</type>,<code> Promotion&lt;T,
          T&gt;::type</code> is <type>T</type> .</para>
        </listitem>

        <listitem>
          <para>For all types <type>T1</type> and<type> T2</type>,<code>
          Promotion&lt;complex&lt;T1&gt;, complex&lt;T2&gt; &gt;::type</code>
          is <code>complex&lt;typename Promotion&lt;T1, T2&gt;::type&gt;,
          Promotion&lt;complex&lt;T1&gt;, T2&gt;::type</code> is
          <code>complex&lt;Promotion&lt;T1, T2&gt;::type&gt;</code>, and
          <code>Promotion&lt;T1, complex&lt;T2&gt; &gt;::type</code> is
          <code>complex&lt;Promotion&lt;T1, T2&gt;::type&gt;</code>, whichever
          applies first.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.errors">
      <title>Domain and range errors</title>

      <titleabbrev>math.fns.errors</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Behavior for domain, range, overflow, and underflow errors and
          for undefined values conforms to VSIPL, i.e., the result is
          undefined behavior. For functions on views defined using scalar
          functions, this behavior is extended element-wise, as defined in
          <xref linkend="math.definitions"/>.</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.scalar">
      <title>Scalar functions</title>

      <titleabbrev>math.fns.scalar</titleabbrev>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">acos</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <type>acos&lt;scalar_f&gt;</type> . An implementation is permitted
            to prevent instantiation of <type>acos&lt;T&gt;</type> for other
            choices of <type>T</type> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The principal radian value in the range <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mo stretchy="false">[</m:mo>

                      <m:mn>0</m:mn>

                      <m:mo>,</m:mo>

                      <m:mi>π</m:mi>

                      <m:mo stretchy="false">]</m:mo>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> of the arccosine of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            vsip_acos_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">add</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>add&lt;scalar_f, cscalar_f&gt;</function> and
            <function>add&lt;cscalar_f, cscalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of add&lt;T1,
            T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The sum of the two operands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_rcadd_f</function> and
            <function>vsip_cadd_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">arg</emphasis>(complex&lt;T&gt; const&amp; a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>arg&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of arg&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The argument of a in radians. See
            <function>vsip_arg_f</function> for the mathematical
            specification.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            vsip_arg_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">asin</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>asin&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of asin&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The principal radian value <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mo stretchy="false">[</m:mo>

                      <m:mn>0</m:mn>

                      <m:mo>,</m:mo>

                      <m:mi>π</m:mi>

                      <m:mo stretchy="false">]</m:mo>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> of the arcsine of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_asin_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">atan</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>atan&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of atan&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The arctangent of a . See vsip_atan_f for the mathematical
            specification.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            vsip_atan_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">atan2</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>atan2&lt;scalar_f, scalar_f&gt;</function>. An
            implementation is permitted to prevent instantiation of
            atan2&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The arctangent of the ratio of a and b. See
            <function>vsip_atan2</function>_f for the mathematical
            specification.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_atan2_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">ceil</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>ceil&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of ceil&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The smallest integral value greater than or equal to the
            argument.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_ceil_f</function>. The return type is the same as
            the argument type, which is not necessarily an integral
            type.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
complex&lt;T&gt; <emphasis role="bold">conj</emphasis>(complex&lt;T&gt; const&amp; a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>conj&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of conj&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The conjugate of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            vsip_conj_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">cos</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>cos&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of cos&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The cosine of a in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_cos_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">cosh</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>cosh&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of cosh&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The hyperbolic cosine of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_cosh_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">div</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>div&lt;cscalar_f, scalar_f&gt;</function>,
            <function>div&lt;scalar_f, cscalar_f&gt;</function>, and
            <function>div&lt;cscalar_f, cscalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of
            <code>div&lt;T1, T2&gt;</code> for other choices of T1 and T2
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The quotient of the two operands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_crdiv_f</function> and
            <function>vsip_cdiv_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">exp</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>exp&lt;scalar_f&gt;</function> and<function>
            exp&lt;cscalar_f&gt;</function> . An implementation is permitted
            to prevent instantiation of exp&lt;T&gt; for other choices of T
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The exponential of a, extended to the complex exponential if
            appropriate.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_exp_f</function> and
            <function>vsip_cexp_f</function>. The exponential <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>exp</m:mi>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mi>a</m:mi>

                      <m:mo stretchy="false">)</m:mo>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> of a complex <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>a</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mo stretchy="false">(</m:mo>

                      <m:mi>cos</m:mi>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mrow>
                        <m:mi fontstyle="normal">imag</m:mi>
                      </m:mrow>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mi>a</m:mi>

                      <m:mo stretchy="false">)</m:mo>

                      <m:mo stretchy="false">)</m:mo>

                      <m:mo>+</m:mo>

                      <m:mi>j</m:mi>

                      <m:mi>sin</m:mi>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mrow>
                        <m:mi fontstyle="normal">imag</m:mi>
                      </m:mrow>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mi>a</m:mi>

                      <m:mo stretchy="false">)</m:mo>

                      <m:mo stretchy="false">)</m:mo>

                      <m:mo stretchy="false">)</m:mo>

                      <m:mi>exp</m:mi>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mrow>
                        <m:mi fontstyle="normal">real</m:mi>
                      </m:mrow>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mi>a</m:mi>

                      <m:mo stretchy="false">)</m:mo>

                      <m:mo stretchy="false">)</m:mo>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>j</m:mi>

                      <m:mo>=</m:mo>

                      <m:msqrt>
                        <m:mrow>
                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:msqrt>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">exp10</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>exp10&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of exp10&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The base-10 exponential of a, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mn>10</m:mn>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>a</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_exp10_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">floor</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>floor&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of floor&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The largest integral value less than or equal to the
            argument.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_floor_f</function>. The return type is the same as
            the argument type, which is not necessarily an integral
            type.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">fmod</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b != 0.0 . The only specialization which must be supported
            is <function>fmod&lt;scalar_f, scalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of
            fmod&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para><code>a - sign(a) * floor(mag(a/b)) * mag(b)</code>, where
            sign(a) is +1 if a is positive, 0 if a is zero, and -1 if a is
            negative.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_fmod_f</function>. The result of operating on
            signed values may differ from C++’s % operation on signed integral
            values.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">hypot</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>hypot&lt;scalar_f, scalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of
            hypot&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>sqrt(a * a + b * b) .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL function
            <function>vsip_hypot_f</function>. Intermediate overflows will not
            occur.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">imag</emphasis>(complex&lt;T&gt; const&amp; a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>imag&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of imag&lt;T&gt; for other
            choices of T.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The imaginary portion of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            vsip_imag_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">jmul</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>jmul&lt;cscalar_f, cscalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of
            jmul&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The product of a with the conjugate of b .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the scalar VSIPL function
            <function>vsip_cjmul_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">log</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>log&lt;scalar_f&gt;</function> and
            <function>log&lt;cscalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of log&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The natural logarithm of a, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>ln</m:mi>

                      <m:mi>a</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, extended to incorporate complex natural
            logarithms.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_log_f</function> and
            <function>vsip_clof_f</function>. The complex logarithm
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>ln</m:mi>

                      <m:mi>a</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> for complex <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>a</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>ln</m:mi>

                      <m:mo stretchy="false">|</m:mo>

                      <m:mi>a</m:mi>

                      <m:mo stretchy="false">|</m:mo>

                      <m:mo>+</m:mo>

                      <m:mi>j</m:mi>

                      <m:mi>arg</m:mi>

                      <m:mo stretchy="false">(</m:mo>

                      <m:mi>a</m:mi>

                      <m:mo stretchy="false">)</m:mo>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>j</m:mi>

                      <m:mo>=</m:mo>

                      <m:msqrt>
                        <m:mrow>
                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:msqrt>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">log10</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>log10&lt;scalar_f&gt;</function>. An implementation is
            permitted to prevent instantiation of
            <function>log10&lt;T&gt;</function> for other choices of
            <type>T</type>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The base-10 logarithm of a, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>log</m:mi>

                      <m:mi>a</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_log10_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">mag</emphasis>(complex&lt;T&gt; const&amp; a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>mag&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of mag&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The magnitude of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_cmag_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">mag</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>mag&lt;scalar_f&gt;</function> and
            <function>mag&lt;scalar_i&gt;</function> . An implementation is
            permitted to prevent instantiation of mag&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The absolute value of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_mag_f</function> and
            <function>vsip_mag_i</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">magsq</emphasis>(complex&lt;T&gt; const&amp; a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>magsq&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of magsq&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The magnitude squared of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_cmagsq_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">max</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>max&lt;scalar_f, scalar_f&gt;</function> and
            <function>max&lt;scalar_i, scalar_i&gt;</function> . An
            implementation is permitted to prevent instantiation of max&lt;T1,
            T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Returns the maximum of a and b .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_max_f</function> and
            <function>vsip_max_i</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">min</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>min&lt;scalar_f, scalar_f&gt;</function> and
            <function>min&lt;scalar_i, scalar_i&gt;</function> . An
            implementation is permitted to prevent instantiation of min&lt;T1,
            T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Returns the minimum of a and b .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_min_f and vsip_min_i.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">mul</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>mul&lt;cscalar_f, cscalar_f&gt;</function> and
            <function>mul&lt;scalar_f, cscalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of mul&lt;T1,
            T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The product of the two operands.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_cmul_f</function> and
            <function>vsip_rcmul_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">neg</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>neg&lt;cscalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of neg&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>-a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL function
            <function>vsip_cneg_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">pow</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>pow&lt;scalar_f, scalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of pow&lt;T1,
            T2&gt; for other choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The power function of a and b, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>a</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>b</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            vsip_pow_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">real</emphasis>(complex&lt;T&gt; const&amp; a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>real&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of real&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The real portion of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_real_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">recip</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>recip&lt;cscalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of recip&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The reciprocal of the operand, extended to complex numbers
            as appropriate.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL function
            <function>vsip_crecip_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">rsqrt</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>rsqrt&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of rsqrt&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The reciprocal of the square root of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL function
            <function>vsip_rsqrt_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">sin</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>sin&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of sin&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The sine of a in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_sin_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">sinh</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>sinh&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of sinh&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The hyperbolic sine of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_sinh_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">sqrt</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>sqrt&lt;scalar_f&gt;</function> and
            <function>sqrt&lt;cscalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of sqrt&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The square root of a, extended to complex numbers as
            appropriate.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            <function>vsip_sqrt_f</function> and
            <function>vsip_csqrt_f</function>. For a mathematical description
            of the complex square root, see the VSIPL description of
            vsip_csqrt_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">sub</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            <function>sub&lt;cscalar_f, scalar_f&gt;</function>,
            <function>sub&lt;scalar_f, cscalar_f&gt;</function>, and
            <function>sub&lt;cscalar_f, cscalar_f&gt;</function> . An
            implementation is permitted to prevent instantiation of sub&lt;T1,
            T2&gt; for other choices of T1 and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>a - b .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            <function>vsip_csub_f</function>,
            <function>vsip_rcsub_f</function>, and
            <function>vsip_crsub_f.</function></para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">tan</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>tan&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of tan&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The tangent of a in radians.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_tan_f</function>.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">tanh</emphasis>(T a) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported is
            <function>tanh&lt;scalar_f&gt;</function> . An implementation is
            permitted to prevent instantiation of tanh&lt;T&gt; for other
            choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The hyperbolic tangent of a .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL function
            <function>vsip_tanh_f.</function></para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.fns.elements">
      <title>Scalar functions used in element-wise extensions</title>

      <titleabbrev>math.fns.elements</titleabbrev>

      <orderedlist>
        <listitem>
          <para>[<emphasis>Note: </emphasis> The following scalar functions
          are described here to ease specification of their element-wise
          extensions in <xref linkend="math.fns.elementwise"/> and <xref
          linkend="math.fns.scalarview"/> and the specification of the
          reduction functions in <xref linkend="math.fns.reductions"/> and
          <xref linkend="math.fns.reductidx"/>. ]</para>
        </listitem>

        <listitem>
          <para>These functions need not be present in the vsip nor in any
          other namespace including the global namespace. Despite this, the
          functions are presented using the same format as in the rest of the
          document so that they can be referenced elsewhere.</para>
        </listitem>

        <listitem>
          <para>If a VSIPL++ implementation does include these functions, they
          may be included in the vsip namespace.</para>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> Some functions appear both here
          and in <xref linkend="math.fns.scalar"/> because the set of required
          specializations differ. For these functions, the union of
          instantiation requirements should be used when interpreting
          element-wise and reduction requirements. ]</para>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">add</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                add&lt;scalar_f, scalar_f&gt; and add&lt;scalar_i,
                scalar_i&gt; . An implementation is permitted to prevent
                instantiation of add&lt;T1, T2&gt; for other choices of T1 and
                T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The sum of the two operands.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vadd_f, vsip_madd_f, vsip_svadd_f, and
                vsip_svadd_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2, typename T3&gt; typename
Promotion&lt;T1, typename Promotion&lt;T2, T3&gt;::type&gt;::type <emphasis
              role="bold">am</emphasis>(T1 a, T2 b, T3 c) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                am&lt;cscalar_f, cscalar_f, cscalar_f&gt; and am&lt;scalar_f,
                scalar_f, scalar_f&gt; . An implementation is permitted to
                prevent instantiation of am&lt;T1, T2, T3&gt; for other
                choices of T1, T2, and T3 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>(a + b) * c .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_cvam_f, vsip_vam_f, vsip_cvsam_f, and
                vsip_vsam_f. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>bool <emphasis role="bold">land</emphasis>(bool a, bool b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><code>a &amp;&amp; b</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vand_bl and vsip_mand_bl. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, and is a keyword so it cannot be used as a
                function name. land abbreviates “logical and.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">band</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                band&lt;scalar_i, scalar_i&gt; . Both T1 and T2 may not both
                be bool . An implementation is permitted to prevent
                instantiation of band&lt;T1, T2&gt; for other choices of T1
                and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a &amp; b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vand_i and vsip_mand_i. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, and is a keyword so it cannot be used as a
                function name. band abbreviates “bitwise and.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">div</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                div&lt;scalar_f, scalar_f&gt; . An implementation is permitted
                to prevent instantiation of div&lt;T1, T2&gt; for other
                choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The quotient of the two operands.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vdiv_f, vsip_mdiv_f, vsip_svdiv_f, and
                vsip_vsdiv_f. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
bool <emphasis role="bold">eq</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                eq&lt;scalar_f, scalar_f&gt; and eq&lt;scalar_i, scalar_i&gt;
                . An implementation is permitted to prevent instantiation of
                eq&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a == b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vleq_f and vsip_mleq_f. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.
                Implementors may wish to implement eq&lt;cscalar_f,
                cscalar_f&gt; and other complex arguments using the C++
                library’s == operator.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T&gt; 
complex&lt;T&gt; <emphasis role="bold">euler</emphasis>(T x) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                euler&lt;scalar_f&gt; . An implementation is permitted to
                prevent instantiation of euler&lt;T&gt; for other choices of T
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The complex number corresponding to the angle of a unit
                vector in the complex plane, i.e., exp(j * x) for argument x
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_veuler_f and vsip_meuler_f. This
                scalar function need not be defined, but this function may be
                used to specify element-wise extensions or reduction
                functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2, typename T3&gt; 
typename Promotion&lt;T1, typename Promotion&lt;T2, T3&gt;::type&gt;::type 
<emphasis role="bold">expoavg</emphasis>(T1 a, T2 b, T3 c) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                expoavg&lt;scalar_f, cscalar_f, cscalar_f&gt; and
                expoavg&lt;scalar_f, scalar_f, scalar_f&gt; . An
                implementation is permitted to prevent instantiation of
                expoavg&lt;T1, T2, T3&gt; for other choices of T1, T2, and T3
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a * b + (1.0-a) * c .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_cvexpoavg_f, vsip_cmexpoavg_f,
                vsip_vexpoavg_f, and vsip_mexpoavg_f. This scalar function
                need not be defined, but this function may be used to specify
                element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; bool <emphasis
              role="bold">ge</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                ge&lt;scalar_f, scalar_f&gt; and ge&lt;scalar_i, scalar_i&gt;
                . An implementation is permitted to prevent instantiation of
                ge&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a &gt;= b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vlge_f, vsip_mlge_f, vsip_vlge_i, and
                vsip_mlge_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; bool <emphasis
              role="bold">gt</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                gt&lt;scalar_f, scalar_f&gt; and gt&lt;scalar_i, scalar_i&gt;
                . An implementation is permitted to prevent instantiation of
                gt&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a &gt; b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vlgt_f, vsip_mlgt_f, vsip_vlgt_i, and
                vsip_mlgt_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt;
bool <emphasis role="bold">le</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                le&lt;scalar_f, scalar_f&gt; and le&lt;scalar_i, scalar_i&gt;
                . An implementation is permitted to prevent instantiation of
                le&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a &lt;= b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vlle_f, vsip_mlle_f, vsip_vlle_i, and
                vsip_mlle_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt;
bool <emphasis role="bold">lt</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                lt&lt;scalar_f, scalar_f&gt; and lt&lt;scalar_i, scalar_i&gt;
                . An implementation is permitted to prevent instantiation of
                lt&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a &lt; b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vllt_f, and vsip_mllt_f, vsip_vllt_i,
                and vsip_mllt_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2, typename T3&gt; 
typename Promotion&lt;T1, typename Promotion&lt;T2, T3&gt;::type&gt;::type 
<emphasis role="bold">ma</emphasis>(T1 a, T2 b, T3 c) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                ma&lt;cscalar_f, cscalar_f, cscalar_f&gt; and ma&lt;scalar_f,
                scalar_f, scalar_f&gt; . An implementation is permitted to
                prevent instantiation of ma&lt;T1, T2, T3&gt; for other
                choices of T1, T2, and T3 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><code>(a * b) + c</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_cvma_f, vsip_vma_f, vsip_cvsmsa_f,
                vsip_vsmsa_f, vsip_cvsma_f, vsip_vsma_f, vsip_cvmsa_f, and
                vsip_vmsa_f. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">maxmg</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                maxmg&lt;scalar_f, scalar_f&gt; . An implementation is
                permitted to prevent instantiation of maxmg&lt;T1, T2&gt; for
                other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mo>max</m:mo>

                          <m:mo stretchy="false">(</m:mo>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mi>a</m:mi>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mo>,</m:mo>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mi>b</m:mi>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mo stretchy="false">)</m:mo>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vmaxmg_f and vsip_mmaxmg_f. This
                scalar function need not be defined, but this function may be
                used to specify element-wise extensions or reduction
                functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type
<emphasis role="bold">maxmgsq</emphasis>(complex&lt;T1&gt; const&amp; a, complex&lt;T2&gt; const&amp; b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                maxmgsq&lt;scalar_f, scalar_f&gt; . An implementation is
                permitted to prevent instantiation of maxmgsq&lt;T1, T2&gt;
                for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mo>max</m:mo>

                          <m:mo stretchy="false">(</m:mo>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mi>a</m:mi>

                          <m:msup>
                            <m:mrow>
                              <m:mo stretchy="false">|</m:mo>
                            </m:mrow>

                            <m:mrow>
                              <m:mn>2</m:mn>
                            </m:mrow>
                          </m:msup>

                          <m:mo>,</m:mo>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mi>b</m:mi>

                          <m:msup>
                            <m:mrow>
                              <m:mo stretchy="false">|</m:mo>
                            </m:mrow>

                            <m:mrow>
                              <m:mn>2</m:mn>
                            </m:mrow>
                          </m:msup>

                          <m:mo stretchy="false">)</m:mo>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vcmaxmgsq_f and vsip_mcmaxmgsq_f. This
                scalar function need not be defined, but this function may be
                used to specify element-wise extensions or reduction
                functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">minmg</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                minmg&lt;scalar_f, scalar_f&gt; . An implementation is
                permitted to prevent instantiation of minmg&lt;T1, T2&gt; for
                other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mo>min</m:mo>

                          <m:mo stretchy="false">(</m:mo>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mi>a</m:mi>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mo>,</m:mo>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mi>b</m:mi>

                          <m:mo stretchy="false">|</m:mo>

                          <m:mo stretchy="false">)</m:mo>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vminmg_f and vsip_mminmg_f. This
                scalar function need not be defined, but this function may be
                used to specify element-wise extensions or reduction
                functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">minmgsq</emphasis>(complex&lt;T1&gt; const&amp;, complex&lt;T2&gt; const&amp;) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                minmgsq&lt;scalar_f, scalar_f&gt; . An implementation is
                permitted to prevent instantiation of minmgsq&lt;T1, T2&gt;
                for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><inlineequation>
                    <m:math>
                      <m:mrow>
                        <m:mo>min</m:mo>

                        <m:mo stretchy="false">(</m:mo>

                        <m:mo stretchy="false">|</m:mo>

                        <m:mi>a</m:mi>

                        <m:msup>
                          <m:mrow>
                            <m:mo stretchy="false">|</m:mo>
                          </m:mrow>

                          <m:mrow>
                            <m:mn>2</m:mn>
                          </m:mrow>
                        </m:msup>

                        <m:mo>,</m:mo>

                        <m:mo stretchy="false">|</m:mo>

                        <m:mi>b</m:mi>

                        <m:msup>
                          <m:mrow>
                            <m:mo stretchy="false">|</m:mo>
                          </m:mrow>

                          <m:mrow>
                            <m:mn>2</m:mn>
                          </m:mrow>
                        </m:msup>

                        <m:mo stretchy="false">)</m:mo>
                      </m:mrow>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vcminmgsq_f and vsip_mcminmgsq_f. This
                scalar function need not be defined, but this function may be
                used to specify element-wise extensions or reduction
                functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2, typename T3&gt; 
typename Promotion&lt;T1, typename Promotion&lt;T2, T3&gt;::type&gt;::type 
<emphasis role="bold">msb</emphasis>(T1 a, T2 b, T3 c) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                msb&lt;cscalar_f, cscalar_f, cscalar_f&gt; and
                msb&lt;scalar_f, scalar_f, scalar_f&gt; . An implementation is
                permitted to prevent instantiation of msb&lt;T1, T2, T3&gt;
                for other choices of T1, T2, and T3 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>(a * b) - c .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_cvmsb_f and vsip_vmsb_f. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">mul</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                mul&lt;scalar_f, scalar_f&gt; and mul&lt;scalar_i,
                scalar_i&gt; . An implementation is permitted to prevent
                instantiation of mul&lt;T1, T2&gt; for other choices of T1 and
                T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The product of the two operands.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of the VSIPL functions vsip_vmul_f, vsip_mmul_f, vsip_vmul_i,
                vsip_mmul_i, and vsip_svmul_f. This scalar function need not
                be defined, but this function may be used to specify
                element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
bool <emphasis role="bold">ne</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                ne&lt;scalar_f, scalar_f&gt; and ne&lt;scalar_i, scalar_i&gt;
                . An implementation is permitted to prevent instantiation of
                ne&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a != b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vlne_f, vsip_mlne_f, vsip_vlne_i, and
                vsip_mlne_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">neg</emphasis>(T a) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                neg&lt;scalar_f&gt; and neg&lt;scalar_i&gt; . An
                implementation is permitted to prevent instantiation of
                neg&lt;T&gt; for other choices of T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>-a .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vneg_f, vsip_mneg_f, vsip_vneg_i and
                vsip_mneg_i. This scalar function need not be defined, but
                this function may be used to specify element-wise extensions
                or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>bool <emphasis role="bold">lnot</emphasis>(bool a) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>!a .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vnot_bl and vsip_mnot_bl. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, not is a keyword so it cannot be used as a
                function name. lnot abbreviates “logical not.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">bnot</emphasis>(T a) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                bnot&lt;scalar_i&gt; . T may not be bool . An implementation
                is permitted to prevent instantiation of bnot&lt;T&gt; for
                other choices of T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>~a .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vnot_i and vsip_mnot_i. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, not is a keyword so it cannot be used as a
                function name. bnot abbreviates “bitwise not.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>bool <emphasis role="bold">lor</emphasis>(bool a, bool b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a || b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vor_bl and vsip_mor_bl. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, or is a keyword so it cannot be used as a
                function name. lor abbreviates “logical or.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">bor</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                bor&lt;scalar_i, scalar_i&gt; . Both T1 and T2 may not be bool
                . An implementation is permitted to prevent instantiation of
                bor&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a | b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vor_i and vsip_mor_i. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, or is a keyword so it cannot be used as a
                function name. bor abbreviates “bitwise or.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">recip</emphasis>(T a) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                recip&lt;scalar_f&gt; . An implementation is permitted to
                prevent instantiation of recip&lt;T&gt; for other choices of T
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The reciprocal of the operand, extended to complex
                numbers as appropriate.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar VSIPL
                functions vsip_vrecip_f and vsip_mrecip_f. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2, typename T3&gt; 
typename Promotion&lt;T1, typename Promotion&lt;T2, T3&gt;::type&gt;::type 
<emphasis role="bold">sbm</emphasis>(T1 a, T2 b, T3 c) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                sbm&lt;cscalar_f, cscalar_f, cscalar_f&gt; and
                sbm&lt;scalar_f, scalar_f, scalar_f&gt; . An implementation is
                permitted to prevent instantiation of sbm&lt;T1, T2, T3&gt;
                for other choices of T1, T2, and T3 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>(a - b) * c .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_cvsbm_f and vsip_vsbm_f. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T&gt; 
T <emphasis role="bold">sq</emphasis>(T) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                sq&lt;scalar_f&gt; . An implementation is permitted to prevent
                instantiation of sq&lt;T&gt; for other choices of T .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The square of the operand, i.e., product with
                itself.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar VSIPL
                functions vsip_vsq_f and vsip_msq_f. This scalar function need
                not be defined, but this function may be used to specify
                element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">sub</emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported are
                sub&lt;scalar_f, scalar_f&gt; and sub&lt;scalar_i,
                scalar_i&gt; . An implementation is permitted to prevent
                instantiation of sub&lt;T1, T2&gt; for other choices of T1 and
                T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>a - b .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of the VSIPL functions vsip_vsub_f, vsip_msub_f, vsip_vsub_i,
                vsip_msub_i, vsip_svsub_f, and vsip_svsub_i. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>bool <emphasis role="bold">lxor</emphasis>(bool, bool) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><code>(a &amp;&amp; !b) || (!a &amp;&amp;
                b)</code>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vxor_bl and vsip_mxor_bl. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, xor is a keyword so it cannot be used as a
                function name. lxor abbreviates “logical xor.”</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">bxor</emphasis>(T1, T2) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specialization which must be supported is
                bxor&lt;scalar_i, scalar_i&gt; . Both T1 and T2 cannot both be
                bool . An implementation is permitted to prevent instantiation
                of bxor&lt;T1, T2&gt; for other choices of T1 and T2 .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para><code>a^b</code> where bool values are interpreted as
                either 0 for false or 1 for true.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the scalar versions
                of VSIPL functions vsip_vxor_i and vsip_mxor_i. This scalar
                function need not be defined, but this function may be used to
                specify element-wise extensions or reduction functions.</para>

                <para>In C++, xor is a keyword so it cannot be used as a
                function name. bxor abbreviates “bitwise xor.”</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.elementwise">
      <title>Scalar functions and their element-wise extensions</title>

      <titleabbrev>math.fns.elementwise</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These function specifications have two portions:</para>

          <itemizedlist>
            <listitem>
              <para>a scalar version defined in terms of a VSIPL function or a
              scalar function in <xref linkend="math.fns.scalar"/> or <xref
              linkend="math.fns.elements"/> and</para>
            </listitem>

            <listitem>
              <para>an element-wise extension to views.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Unless otherwise noted, the element-wise extension of scalar
          unary function f to a constant view const_View <variablelist>
              <varlistentry>
                <term>Requires:</term>

                <listitem>
                  <para>One parameter const_View v where const_View is a
                  constant view class such that f(val) is valid C++ where val
                  has the type View::value_type .</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Returns:</term>

                <listitem>
                  <para>A const view with type const_View and value type the
                  same as the type of f(const_View::value_type) and having a
                  domain element-conformant to v’s domain. Each value equals
                  f(val) where val is the corresponding value in v .</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Note:</term>

                <listitem>
                  <para>The type of the block of the returned view may be
                  different than the type of v’s block.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </listitem>

        <listitem>
          <para>The element-wise extension of a scalar binary function f to a
          constant view const_View similarly <variablelist>
              <varlistentry>
                <term>Requires:</term>

                <listitem>
                  <para>Two parameters const_View1 v and const_View2 w where
                  const_View1 and const_View2 are view classes such that
                  f(v_val, w_val) is valid C++ where v_val and w_val have
                  types const_View1::value_type and const_View2::value_type,
                  respectively. v and w are element-conformant.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Returns:</term>

                <listitem>
                  <para>A constant view with type const_View and value type
                  the same as the type of f(const_View1::value_type,
                  const_View2::value_type) and having a domain
                  element-conformant to v’s domain. Each value equals f(val1,
                  val2) where val1 and val2 are the corresponding values in v
                  and w, respectively.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Note:</term>

                <listitem>
                  <para>The type of the block of the returned view may be
                  different than the types of v’s and w’s blocks.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </listitem>

        <listitem>
          <para>Element-wise extension of <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>n</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>-ary functions to a view is analogously
          specified.</para>
        </listitem>

        <listitem>
          <para>The scalar unary, binary, and ternary functions listed in
          <xref linkend="math_fn-real-elementwise-table"/> all conform to the
          above paragraphs by having element-wise extensions. The table’s
          third column indicates which view classes must support element-wise
          extensions using the following abbreviations:</para>

          <variablelist>
            <varlistentry>
              <term>V:</term>

              <listitem>
                <para>Vector</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>M:</term>

              <listitem>
                <para>Matrix</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>T:</term>

              <listitem>
                <para>Tensor</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>An implementation is permitted to prevent instantiation for
          other choices of View, View1, and View2 .</para>

          <table xml:id="math_fn-real-elementwise-table">
            <caption>Integral, real, complex, and boolean functions with
            element-wise extensions</caption>

            <thead>
              <tr>
                <th>function</th>

                <th>meaning</th>

                <th>views</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><code>acos</code></td>

                <td>arccosine</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>add</code></td>

                <td>addition</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>am</code></td>

                <td>addition then product</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>land</code></td>

                <td>logical and</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>band</code></td>

                <td>bitwise and</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>arg</code></td>

                <td>real scalar in radians</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>asin</code></td>

                <td>arcsin</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>atan</code></td>

                <td>arctangent</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>atan2</code></td>

                <td>two-argument arctangent</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>ceil</code></td>

                <td>ceiling</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>conj</code></td>

                <td>complex conjugate</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>cos</code></td>

                <td>cosine</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>cosh</code></td>

                <td>hyperbolic cosine</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>div</code></td>

                <td>division</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>eq</code></td>

                <td>equality</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>euler</code></td>

                <td>complex exponential</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>exp</code></td>

                <td>exponential</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>exp10</code></td>

                <td>base-10 exponential</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>floor</code></td>

                <td>floor</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>fmod</code></td>

                <td>remainder</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>ge</code></td>

                <td>greater than or equal</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>gt</code></td>

                <td>greater than</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>hypot</code></td>

                <td>square root of sum of squares</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>imag</code></td>

                <td>imaginary part of complex</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>jmul</code></td>

                <td>product with complex conjugate</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>le</code></td>

                <td>less than or equal</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>log</code></td>

                <td>natural logarithm</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>log10</code></td>

                <td>base-10 logarithm</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>lt</code></td>

                <td>less than</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>ma</code></td>

                <td>product and addition</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>mag</code></td>

                <td>absolute value</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>magsq</code></td>

                <td>squared magnitude</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>max</code></td>

                <td>maximum</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>maxmg</code></td>

                <td>maximum magnitude</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>maxmgsq</code></td>

                <td>maximum magnitude squared</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>min</code></td>

                <td>minimum</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>minmg</code></td>

                <td>minimum magnitude</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>minmgsq</code></td>

                <td>minimum magnitude squared</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>msb</code></td>

                <td>product and subtraction</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>mul</code></td>

                <td>product</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>ne</code></td>

                <td>not equal</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>neg</code></td>

                <td>negation</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>lnot</code></td>

                <td>logical not</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>bnot</code></td>

                <td>bitwise not</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>lor</code></td>

                <td>logical or</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>bor</code></td>

                <td>bitwise or</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>pow</code></td>

                <td>power function</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>real</code></td>

                <td>real part of complex</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>recip</code></td>

                <td>reciprocal</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>rsqrt</code></td>

                <td>reciprocal square root</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sbm</code></td>

                <td>subtraction and product</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>sin</code></td>

                <td>sine</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sinh</code></td>

                <td>hyperbolic sine</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sq</code></td>

                <td>square</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sqrt</code></td>

                <td>square root</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sub</code></td>

                <td>subtraction</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>tan</code></td>

                <td>tangent</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>tanh</code></td>

                <td>hyperbolic tangent</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>lxor</code></td>

                <td>logical exclusive-or</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>bxor</code></td>

                <td>bitwise exclusive-or</td>

                <td>VM</td>
              </tr>
            </tbody>
          </table>

          <synopsis>template &lt;typename T1, 
          typename T2, 
          template &lt;typename, typename&gt; class const_View, 
          typename Block1,
          typename Block2&gt;
const_View&lt;complex&lt;typename Promotion&lt;T1, T2&gt;::type&gt;, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">cmplx</emphasis>(const_View&lt;T1, Block1&gt; v, const_View&lt;T2, Block2&gt; w) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T1
                and T2 both equal to scalar_f and const_View equal to
                const_Vector or const_Matrix . An implementation is permitted
                to prevent instantiation with other values. v and w must be
                element conformant.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The element-wise extension of the complex(T1, T2)
                constructor to views.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vcmplx_f and vsip_mcmplx_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.scalarview">
      <title>Element-wise functions with scalar and view operands</title>

      <titleabbrev>math.fns.scalarview</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These function specifications define an element-wise extension
          of a function on a view and a scalar or on a scalar and a view using
          a scalar function defined in terms of a VSIPL binary function or a
          scalar binary function in <xref linkend="math.fns.scalar"/> or <xref
          linkend="math.fns.elements"/>.</para>
        </listitem>

        <listitem>
          <para>The element-wise extension of a scalar binary function f to a
          view and a scalar <variablelist>
              <varlistentry>
                <term>Requires:</term>

                <listitem>
                  <para>Two parameters const_View1 v and scalartype s where
                  const_View1 is a constant view class such that f(val, s) is
                  valid C++ where val has type View1::value_type and s has
                  type scalartype .</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Returns:</term>

                <listitem>
                  <para>A constant view with value type the same as the type
                  of f(const_View1::value_type, scalartype) and having a
                  domain element-conformant to v’s domain. Each value equals
                  f(val, s) where val is the corresponding value in v .</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Note:</term>

                <listitem>
                  <para>The type of the block of the returned view may be
                  different than the type of v’s block.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </listitem>

        <listitem>
          <para>The element-wise extension of a scalar binary function f to a
          scalar and a view is specified analogously.</para>
        </listitem>

        <listitem>
          <para>The element-wise extension of a scalar ternary function f to a
          scalar, a view, and a view <variablelist>
              <varlistentry>
                <term>Requires:</term>

                <listitem>
                  <para>Three parameters scalartype s, const_View1 v, and
                  const_View2 w where const_View1 and const_View2 are view
                  classes such that f(s, v_val, w_val) is valid C++, s has
                  type scalartype, v_val has type const_View1::value_type,
                  w_val has type const_View2::value_type . v and w are
                  element-conformant.</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Returns:</term>

                <listitem>
                  <para>A view with value type the same as the type of
                  f(scalartype, const_View1::value_type,
                  const_View2::value_type) and having a domain
                  element-conformant to v’s domain. Each value equals f(s,
                  v_val, w_val) where v_val and w_val are corresponding values
                  in v and w .</para>
                </listitem>
              </varlistentry>

              <varlistentry>
                <term>Note:</term>

                <listitem>
                  <para>The type of the block of the returned view may be
                  different than the types of v’s and w’s blocks.</para>
                </listitem>
              </varlistentry>
            </variablelist></para>
        </listitem>

        <listitem>
          <para>The element-wise extension of a scalar ternary function f to
          two views and a scalar is specified analogously. The element-wise
          extension of a scalar ternary function f to a view, a scalar, and a
          view is specified analogously. The element-wise extension of a
          scalar ternary function f to a view and two scalars is specified
          analogously.</para>
        </listitem>

        <listitem>
          <para>The functions listed in <xref
          linkend="math_fn-real-scalarview-table"/> all conform to the above
          paragraphs. The rightmost column indicates which classes must
          support element-wise extensions using the following
          abbreviations:</para>

          <variablelist>
            <varlistentry>
              <term>V:</term>

              <listitem>
                <para>const_Vector</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>M:</term>

              <listitem>
                <para>const_Matrix</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>T:</term>

              <listitem>
                <para>const_Tensor</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <para>const_View::value_type, const_View1::value_type,
          const_View2::value_type, T, T1, and T2 can all represent distinct
          types. const_View, const_View1, and const_View2 each abbreviate
          const_View&lt;Tp, Blockp&gt; for appropriate values of Tp and Blockp
          .</para>

          <table xml:id="math_fn-real-scalarview-table">
            <caption>Functions with elementwise extensions on views and
            scalars</caption>

            <thead>
              <tr>
                <th>function</th>

                <th>meaning</th>

                <th>views</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><code>add(T, const_View)</code></td>

                <td>addition</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>add(const_View, T)</code></td>

                <td>addition</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>am(const_View1, T, const_View2)</code></td>

                <td>addition and product</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>div(T, const_View)</code></td>

                <td>division</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>div(const_View, T)</code></td>

                <td>division</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>expoavg(T, const_View1, const_View2)</code></td>

                <td>exponential average</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>ma(const_View1, T1, T2)</code></td>

                <td>multiply and add</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>ma(const_View1, T, const_View2)</code></td>

                <td>multiply and add</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>ma(const_View1, const_View2, T)</code></td>

                <td>multiply and add</td>

                <td>V</td>
              </tr>

              <tr>
                <td><code>mul(T, const_View)</code></td>

                <td>product</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>mul(const_View, T)</code></td>

                <td>product</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sub(T, const_View)</code></td>

                <td>subtraction</td>

                <td>VM</td>
              </tr>

              <tr>
                <td><code>sub(const_View, T)</code></td>

                <td>subtraction</td>

                <td>VM</td>
              </tr>
            </tbody>
          </table>
        </listitem>

        <listitem>
          <para>Instantiation requirements follow directly from the
          instantiation requirements for the underlying scalar function.
          [<emphasis>Example: </emphasis> The only specializations of the
          element-wise extension of am to a view, a scalar, and another view
          which must be supported have const_View1::value_type, T, and
          const_View2::value_type all equal and all equal to cscalar_f or
          scalar_f because the only specializations of the scalar function
          which must be supported are am&lt;cscalar_f, cscalar_f,
          cscalar_f&gt; and am&lt;scalar_f, scalar_f, scalar_f&gt;. ]</para>
        </listitem>

        <listitem>
          <para>An implementation is permitted to prevent instantiation of
          div(const_View, T) for complex T .</para>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.userelt">
      <title>Element-wise extension of user-specified functions</title>

      <titleabbrev>math.fns.userelt</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Element-wise extensions of user-specified functions
          element-wise apply a function pointer or function object to the
          appropriate number of views.</para>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> VSIPL++ specifies binary
          functions that correspond to VSIPL vsip_sbinary and
          vsip_sbool_<emphasis>p</emphasis> functions. bool is a C++ keyword
          so using it as a function name is forbidden by C++. ]</para>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> The VSIPL++ unary, binary, and
          ternary functions each provide portions of the VSIPL vsip_snary
          functionality. ]</para>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> unary and binary are overloaded
          to accept different types of function objects and pointers. The
          first version takes a function object and requires the user to
          explicitly specify the return type as a template argument. The
          second version takes a function pointer and also requires an
          explicit return type template argument. The third version accepts
          function objects obeying (ISO14882, [lib.function.objects]). These
          function objects use internal type definitions to indicate the
          argument and return types so no explicit return type template
          argument is required. The &lt;functional&gt; header file must be
          included to use this.</para>

          <para>ternary has only two versions because C++ does not specify a
          function object with three arguments. ]</para>

          <synopsis>template &lt;typename O, 
          typename UnaryFunction, 
          template &lt;typename, typename&gt; class const_View, 
          typename I, 
          typename Block&gt; 
const_View&lt;O, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">unary</emphasis>(UnaryFunction f, const_View&lt;I, Block&gt; v);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>If input is an instance of I, the expression f(input)
                must yield a value with type O. The only specializations which
                must be supported must satisfy one of these groups of
                constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para>UnaryFunction is a function pointer. I and O must
                    have the same type. If const_View is const_Vector, then I
                    must equal scalar_f, scalar_i, Index&lt;1&gt;,
                    Index&lt;2&gt;, or Index&lt;3&gt; . If const_View is
                    const_Matrix or const_Tensor, then I must equal scalar_f
                    or scalar_i .</para>
                  </listitem>

                  <listitem>
                    <para>UnaryFunction is a function pointer. I equals
                    index_type . const_View equals const_Vector . O equals
                    scalar_f, scalar_i, bool, Index&lt;1&gt;, Index&lt;2&gt;,
                    or Index&lt;3&gt; .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex I or O .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val) where val is the corresponding value in v
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>The order that f is applied to the values in v is
                unspecified. The type of the block of the returned view may be
                different than the type of v’s block. This function
                corresponds to VSIPL functions vsip_vunary_f, vsip_munary_f,
                vsip_tunary_f, vsip_vunary_i, vsip_munary_i, vsip_tunary_i,
                vsip_vunary_vi, vsip_vunary_mi, and vsip_vunary_ti. It also
                corresponds to vsip_vnary_f, vsip_vnary_i, vsip_vnary_bl,
                vsip_vnary_vi, vsip_vnary_mi, and vsip_vnary_ti.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename O, 
          template &lt;typename, typename&gt; class const_View, 
          typename I, 
          typename Block&gt;
const_View&lt;O, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">unary</emphasis>(O (*f)(I), const_View&lt;I, Block&gt; v);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported must
                satisfy one of these groups of constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para>I and O must have the same type. If const_View is
                    const_Vector, then I must equal scalar_f, scalar_i,
                    Index&lt;1&gt;, Index&lt;2&gt;, or Index&lt;3&gt; . If
                    const_View is const_Matrix or const_Tensor, then I must
                    equal scalar_f or scalar_i .</para>
                  </listitem>

                  <listitem>
                    <para>I equals index_type . const_View equals const_Vector
                    . O equals scalar_f, scalar_i, bool, Index&lt;1&gt;,
                    Index&lt;2&gt;, or Index&lt;3&gt; .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex I or O .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A view element-conformant with v where each value equals
                f(val) where val is the corresponding value in v .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This function overloads the more general unary function
                to provide explicit support for function pointers. The order
                that f is applied to the values in v is unspecified. The type
                of the block of the returned view may be different than the
                type of v’s block. This function corresponds to VSIPL
                functions vsip_vunary_f, vsip_munary_f, vsip_tunary_f,
                vsip_vunary_i, vsip_munary_i, vsip_tunary_i, vsip_vunary_vi,
                vsip_vunary_mi, and vsip_vunary_ti. It also corresponds to
                vsip_vnary_f, vsip_vnary_i, vsip_vnary_bl, vsip_vnary_vi,
                vsip_vnary_mi, and vsip_vnary_ti.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename UnaryFunction, 
          template &lt;typename, typename&gt; class const_View, 
          typename Block&gt; 
const_View&lt;typename UnaryFunction::result_type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">unary</emphasis>(UnaryFunction f, const_View&lt;typename UnaryFunction::argument_type, Block&gt;);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para><type>UnaryFunction</type> must be a class such that
                <code>UnaryFunction::result_type</code> and
                <code>UnaryFunction::argument_type</code> are defined and have
                a function operator<code> typename UnaryFunction::result_type
                operator()(typename UnaryFunction::argument_type)</code>. The
                only specializations which must be supported must satisfy one
                of these groups of constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para>UnaryFunction::argument_type and
                    UnaryFunction::result_type must have the same type. If
                    const_View is const_Vector, then
                    UnaryFunction::argument_type must equal scalar_f,
                    scalar_i, Index&lt;1&gt;, Index&lt;2&gt;, or
                    Index&lt;3&gt; . If const_View is const_Matrix or
                    const_Tensor, then UnaryFunction::argument_type must equal
                    scalar_f or scalar_i .</para>
                  </listitem>

                  <listitem>
                    <para>UnaryFunction::argument_type equals index_type .
                    const_View equals const_Vector .
                    UnaryFunction::result_type equals scalar_f, scalar_i,
                    bool, Index&lt;1&gt;, Index&lt;2&gt;, or Index&lt;3&gt;
                    .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex
                <code>UnaryFunction::argument_type</code> or
                <code>UnaryFunction::result_type</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val) where val is the corresponding value in v
                .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This function overloads the more general unary function
                to provide explicit support for function objects obeying
                (ISO14882, [lib.function.objects]). The order that f is
                applied to the values in v is unspecified. The type of the
                block of the returned view may be different than the type of
                v’s block. This function corresponds to VSIPL functions
                vsip_vunary_f, vsip_munary_f, vsip_tunary_f, vsip_vunary_i,
                vsip_munary_i, vsip_tunary_i, vsip_vunary_vi, vsip_vunary_mi,
                and vsip_vunary_ti. It also corresponds to vsip_vnary_f,
                vsip_vnary_i, vsip_vnary_bl, vsip_vnary_vi, vsip_vnary_mi, and
                vsip_vnary_ti.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename O, typename BinaryFunction,
          template &lt;typename, typename&gt; class const_View, 
          typename I0, typename Block0, typename I1, typename Block1&gt;
const_View&lt;O, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">
binary</emphasis>(BinaryFunction f, const_View&lt;I0, Block0&gt; const v, const_View&lt;I2, Block1&gt; w);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>If input0 is an instance of <type>I0</type> and input1
                is an instance of <type>I1</type>, the expression f(input0,
                input1) must yield a value with type <type>O</type>. v and w
                must be element-conformant. The only specializations which
                must be supported must satisfy one of these groups of
                constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para>BinaryFunction is a function pointer.<type>
                    I0</type> and <type>O</type> must have the same type.
                    <type>I0</type> equals <type>I1</type> . If
                    <type>const_View</type> is <type>const_Vector</type>, then
                    <type>I0</type> must equal scalar_f, scalar_i,
                    Index&lt;1&gt;, Index&lt;2&gt;, or Index&lt;3&gt; . If
                    <type>const_View</type> is <type>const_Matrix</type> or
                    <type>const_Tensor</type>, then <type>I0</type> must equal
                    scalar_f, scalar_i, or bool .</para>
                  </listitem>

                  <listitem>
                    <para>BinaryFunction is a function pointer. <type>O</type>
                    must equal bool . <type>I0</type> equals<type> I1</type>.
                    If <type>const_View</type> is <type>const_Vector</type>,
                    then <type>I0</type> must equal scalar_f, scalar_i,
                    Index&lt;1&gt;, Index&lt;2&gt;, or Index&lt;3&gt; . If
                    const_View is const_Matrix or const_Tensor, then
                    <type>I0</type> must equal scalar_f or scalar_i .</para>
                  </listitem>

                  <listitem>
                    <para>BinaryFunction is a function pointer.
                    <type>I0</type> equals<type> I1</type> . <type>I0</type>
                    equals <type>index_type</type> . <type>const_View</type>
                    equals <type>const_Matrix</type> . <type>O</type> equals
                    scalar_f, scalar_i, or bool .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex<type>
                I0</type>, <type>I1</type>, or <type>O</type> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val0, val1) where val0 and val1 are the
                corresponding values in v and w, respectively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>The order that f is applied to the values in v and w is
                unspecified. The type of the block of the returned view may be
                different than the types of v’s and w’s blocks. This function
                corresponds to VSIPL functions vsip_vbinary_f, vsip_mbinary_f,
                vsip_tbinary_f, vsip_vbinary_i, vsip_mbinary_i,
                vsip_tbinary_i, vsip_vbinary_vi, vsip_vbinary_mi,
                vsip_vbinary_ti, and vsip_mbinary_bl, vsip_tbinary_bl. It also
                corresponds to vsip_vbool_f, vsip_mbool_f, vsip_tbool_f,
                vsip_vbool_i, vsip_mbool_i, vsip_tbool_i, vsip_vbool_vi,
                vsip_vbool_mi, and vsip_vbool_ti. It also corresponds to
                vsip_mnary_f, vsip_mnary_i, and vsip_mnary_bl.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename O, template &lt;typename,
          typename&gt; class const_View, typename I0, typename Block0,
          typename I1, typename Block1&gt; 
const_View&lt;O, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">binary</emphasis>(O (*f)(I0, I1), const_View&lt;I0, Block0&gt; v, const_View&lt;I1, Block1&gt; w);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>If input0 is an instance of <type>I0</type> and input1
                is an instance of <type>I1</type>, the expression f(input0,
                input1) must yield a value with type <type>O</type> . v and w
                must be element-conformant. The only specializations which
                must be supported must satisfy one of these groups of
                constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para><type>I0</type> and O must have the same type.
                    <type>I0</type> equals <type>I1</type> . If
                    <type>const_View</type> is <type>const_Vector</type>,
                    then<type> I0</type> must equal scalar_f, scalar_i,
                    Index&lt;1&gt;, Index&lt;2&gt;, or Index&lt;3&gt; . If
                    const_View is const_Matrix or const_Tensor, then
                    <type>I0</type> must equal scalar_f, scalar_i, or bool
                    .</para>
                  </listitem>

                  <listitem>
                    <para><type>O</type> must equal bool . <type>I0</type>
                    equals <type>I1</type> . If <type>const_View</type> is
                    <type>const_Vector</type>, then <type>I0</type> must equal
                    scalar_f, scalar_i, Index&lt;1&gt;, Index&lt;2&gt;, or
                    Index&lt;3&gt; . If <type>const_View</type> is
                    <type>const_Matrix</type> or <type>const_Tensor</type>,
                    then<type> I0</type> must equal scalar_f or scalar_i
                    .</para>
                  </listitem>

                  <listitem>
                    <para><type>I0</type> equals <type>I1</type> .
                    <type>I0</type> equals <type>index_type</type> .
                    <type>const_View</type> equals <type>const_Matrix</type> .
                    <type>O</type> equals scalar_f, scalar_i, or bool .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex
                <type>I0</type>, <type>I1</type>, or <type>O</type> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val0, val1) where val0 and val1 are the
                corresponding values in v and w, respectively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This function overloads the more general binary function
                to provide explicit support for function pointers. The order
                that f is applied to the values in v and w is unspecified. The
                type of the block of the returned view may be different than
                the types of v’s and w’s blocks. This function corresponds to
                VSIPL functions vsip_vbinary_f, vsip_mbinary_f,
                vsip_tbinary_f, vsip_vbinary_i, vsip_mbinary_i,
                vsip_tbinary_i, vsip_vbinary_vi, vsip_vbinary_mi,
                vsip_vbinary_ti, and vsip_mbinary_bl, vsip_tbinary_bl. It also
                corresponds to vsip_vbool_f, vsip_mbool_f, vsip_tbool_f,
                vsip_vbool_i, vsip_mbool_i, vsip_tbool_i, vsip_vbool_vi,
                vsip_vbool_mi, and vsip_vbool_ti. It also corresponds to
                vsip_mnary_f, vsip_mnary_i, and vsip_mnary_bl.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename BinaryFunction, template &lt;typename,
      typename&gt; class const_View, typename Block0, typename Block1&gt; 
const_View&lt;typename BinaryFunction::result_type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">binary</emphasis>(BinaryFunction f, 
       const_View&lt;typename BinaryFunction::first_argument_type, Block0&gt;, 
       const_View&lt;typename BinaryFunction::second_argument_type, Block1&gt;);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>BinaryFunction must be a class such that
                BinaryFunction::result_type,
                BinaryFunction::first_argument_type, and
                BinaryFunction::second_argument_type are defined and have a
                function operator <code>typename BinaryFunction::result_type
                operator()(typename BinaryFunction::first_argument_type,
                typename BinaryFunction::second_argument_type)</code>. v and w
                must be element-conformant. The only specializations which
                must be supported must satisfy one of these groups of
                constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para><type>BinaryFunction::first_argument_type</type> and
                    <type>BinaryFunction::result_type</type> must have the
                    same type.
                    <type>BinaryFunction::first_argument_type</type> equals
                    <type>BinaryFunction::second_argument_type</type> . If
                    <type>const_View</type> is <type>const_Vector</type>,
                    then<code> BinaryFunction::first_argument_type</code> must
                    equal scalar_f, scalar_i, Index&lt;1&gt;, Index&lt;2&gt;,
                    or Index&lt;3&gt; . If <type>const_View</type> is
                    <type>const_Matrix</type> or <type>const_Tensor</type>,
                    then <code>BinaryFunction::first_argument_type</code> must
                    equal scalar_f, scalar_i, or bool .</para>
                  </listitem>

                  <listitem>
                    <para><code>BinaryFunction::result_type</code> must equal
                    bool . <code>BinaryFunction::first_argument_type</code>
                    equals <code>BinaryFunction::second_argument_type</code> .
                    If const_View is const_Vector, then
                    <code>BinaryFunction::first_argument_type</code> must
                    equal scalar_f, scalar_i, Index&lt;1&gt;, Index&lt;2&gt;,
                    or Index&lt;3&gt; . If const_View is const_Matrix or
                    const_Tensor, then
                    <code>BinaryFunction::first_argument_type</code> must
                    equal scalar_f or scalar_i .</para>
                  </listitem>

                  <listitem>
                    <para><code>BinaryFunction::first_argument_type</code>
                    equals <code>BinaryFunction::second_argument_type</code> .
                    <code>BinaryFunction::first_argument_type</code> equals
                    index_type . const_View equals const_Matrix .
                    <code>BinaryFunction::result_type</code> equals scalar_f,
                    scalar_i, or bool .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex
                <code>BinaryFunction::first_argument_type</code>,
                <code>BinaryFunction::second_argument_type</code>, or
                <code>BinaryFunction::result_type</code> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val0, val1) where val0 and val1 are the
                corresponding values in v and w, respectively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This function overloads the more general binary function
                to provide explicit support for function objects obeying
                (ISO14882, [lib.function.objects]). The order that f is
                applied to the values in v and w is unspecified. The type of
                the block of the returned view may be different than the types
                of v’s and w’s blocks. This function corresponds to VSIPL
                functions vsip_vbinary_f, vsip_mbinary_f, vsip_tbinary_f,
                vsip_vbinary_i, vsip_mbinary_i, vsip_tbinary_i,
                vsip_vbinary_vi, vsip_vbinary_mi, vsip_vbinary_ti, and
                vsip_mbinary_bl, vsip_tbinary_bl. It also corresponds to
                vsip_vbool_f, vsip_mbool_f, vsip_tbool_f, vsip_vbool_i,
                vsip_mbool_i, vsip_tbool_i, vsip_vbool_vi, vsip_vbool_mi, and
                vsip_vbool_ti. It also corresponds to vsip_mnary_f,
                vsip_mnary_i, and vsip_mnary_bl.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename O, 
          typename TernaryFunction,
          template &lt;typename, typename&gt; class const_View, 
          typename I0, 
          typename Block0, 
          typename I1, 
          typename Block1, 
          typename I2, 
          typename Block2&gt; 
const_View&lt;O, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">
ternary</emphasis>(TernaryFunction f, 
        const_View&lt;I0, Block0&gt; v, 
        const_View&lt;I1, Block1&gt; w, 
        const_View&lt;I2, Block2&gt; x);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>If input0 is an instance of <type>I0</type>, input1 is
                an instance of <type>I1</type>, and input2 is an instance of
                <type>I2</type>, the expression f(input0, input1, input2) must
                yield a value with type <type>O</type> . v, w, and x must be
                element-conformant. The only specializations which must be
                supported must satisfy this group of constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para>TernaryFunction is a function pointer.
                    <type>I0</type> equals <type>I1</type> and <type>I2</type>
                    .<type> I0</type> equals index_type . const_View equals
                    const_Matrix . <type>O</type> equals scalar_f, scalar_i,
                    or bool .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex
                <type>I0</type>, <type>I1</type>, <type>I2</type>, or
                <type>O</type>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val0, val1, val2) where val0, val1, and val2
                are the corresponding values in v, w, and x,
                respectively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>The order that f is applied to the values in v, w, and x
                is unspecified. The type of the block of the returned view may
                be different than the types of v’s, w’s, and x’s blocks. This
                function corresponds to VSIPL functions vsip_tnary_f,
                vsip_tnary_i, and vsip_tnary_bl.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename O, template &lt;typename, typename&gt; class const_View, 
          typename I0, typename Block0,
          typename I1, typename Block1, 
          typename I2, typename Block2&gt; 
const_View&lt;O, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">
ternary</emphasis>(O (*f)(I0, I1, I2), 
        const_View&lt;I0, Block0&gt; v, 
        const_View&lt;I1, Block1&gt; w, 
        const_View&lt;I2, Block2&gt; x);</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>v, w, and x must be element-conformant. The only
                specializations which must be supported must satisfy this
                group of constraints:</para>

                <itemizedlist>
                  <listitem>
                    <para><type>I0</type> equals <type>I1</type> and
                    <type>I2</type> . <type>I0</type> equals
                    <type>index_type</type> . <type>const_View</type> equals
                    <type>const_Matrix</type> . <type>O</type> equals
                    scalar_f, scalar_i, or bool .</para>
                  </listitem>
                </itemizedlist>

                <para>Regardless of constraint group, an implementation is
                permitted to prevent instantiation for complex
                <type>I0</type>, <type>I1</type>, <type>I2</type>, or
                <type>O</type> .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>A constant view element-conformant with v where each
                value equals f(val0, val1, val2) where val0, val1, and val2
                are the corresponding values in v, w, and x,
                respectively.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>This function overloads the more general ternary
                function to provide explicit support for function pointers.
                The order that f is applied to the values in v, w, and x is
                unspecified. The type of the block of the returned view may be
                different than the types of v’s, w’s, and x’s blocks. This
                function corresponds to VSIPL functions vsip_tnary_f,
                vsip_tnary_i, and vsip_tnary_bl.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.reductions">
      <title>Reduction functions</title>

      <titleabbrev>math.fns.reductions</titleabbrev>

      <orderedlist>
        <listitem>
          <para>A <emphasis>reduction function</emphasis>, given a constant
          view, returns a scalar computed using all the view’s values.</para>
        </listitem>

        <listitem>
          <para>An <emphasis>accumulation operator</emphasis> F with
          <emphasis>base value</emphasis> bv applied to a constant view v
          yields answer ans determined by this algorithm: First, ans = bv .
          For each value val in v, ans = F(ans, val) . The order for accessing
          the values in v is unspecified.</para>
        </listitem>

        <listitem>
          <para>An <emphasis>accumulation operator</emphasis> F with
          <emphasis>base value</emphasis> bv applied to a set <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>S</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> of values yields answer ans determined by this
          algorithm: First, ans = bv . For each s in <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>S</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>, ans = F(ans, s)). The order for traversing
          <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>S</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> is unspecified.</para>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> Most reduction functions f from a
          constant view const_View v to a scalar can be defined using three
          pieces: <itemizedlist>
              <listitem>
                <para>a function s on the view’s domain’s size returning a
                scalar with type t,</para>
              </listitem>

              <listitem>
                <para>an accumulation operator F taking a scalar with type t
                and a v value,x returning a scalar with type t, and</para>
              </listitem>

              <listitem>
                <para>a function c taking a const_View::value_type and
                yielding scalars with type t .</para>
              </listitem>
            </itemizedlist> <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>f</m:mi>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>v</m:mi>

                    <m:mo stretchy="false">)</m:mo>

                    <m:mo>=</m:mo>

                    <m:mi>s</m:mi>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>v</m:mi>

                    <m:mo>.</m:mo>

                    <m:mi>size</m:mi>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mo stretchy="false">)</m:mo>

                    <m:mo stretchy="false">)</m:mo>

                    <m:mo>*</m:mo>

                    <m:msub>
                      <m:mi>F</m:mi>

                      <m:mrow>
                        <m:mi>i</m:mi>

                        <m:mo>∈</m:mo>

                        <m:mi>v</m:mi>

                        <m:mtext>'s domain</m:mtext>
                      </m:mrow>
                    </m:msub>

                    <m:mi>c</m:mi>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>v</m:mi>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>i</m:mi>

                    <m:mo stretchy="false">)</m:mo>

                    <m:mo stretchy="false">)</m:mo>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>. ]</para>
        </listitem>

        <listitem>
          <para>[<emphasis>Example: </emphasis> The mean of a constant view
          can be represented using <itemizedlist>
              <listitem>
                <para><inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>s</m:mi>

                          <m:mo stretchy="false">(</m:mo>

                          <m:mi>sz</m:mi>

                          <m:mo stretchy="false">)</m:mo>

                          <m:mo>=</m:mo>

                          <m:mn>1</m:mn>

                          <m:mo stretchy="false">/</m:mo>

                          <m:mi>sz</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>,</para>
              </listitem>

              <listitem>
                <para>F is the addition operator, and</para>
              </listitem>

              <listitem>
                <para><inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>c</m:mi>

                          <m:mo stretchy="false">(</m:mo>

                          <m:mi>val</m:mi>

                          <m:mo stretchy="false">)</m:mo>

                          <m:mo>=</m:mo>

                          <m:mi>val</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </itemizedlist> For example, the mean of a Matrix m with a
          <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>M</m:mi>

                    <m:mo>×</m:mo>

                    <m:mi>N</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> domain is <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mn>1</m:mn>

                    <m:mo stretchy="false">/</m:mo>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>MN</m:mi>

                    <m:mo stretchy="false">)</m:mo>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>i</m:mi>

                          <m:mo>=</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>M</m:mi>

                          <m:mo>-</m:mo>

                          <m:mi>1</m:mi>
                        </m:mrow>
                      </m:munderover>
                    </m:mrow>

                    <m:mrow>
                      <m:munderover>
                        <m:mo>∑</m:mo>

                        <m:mrow>
                          <m:mi>j</m:mi>

                          <m:mo>=</m:mo>

                          <m:mi>0</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>N</m:mi>

                          <m:mo>-</m:mo>

                          <m:mi>1</m:mi>
                        </m:mrow>
                      </m:munderover>
                    </m:mrow>

                    <m:mi>m</m:mi>

                    <m:mo>.</m:mo>

                    <m:mi>get</m:mi>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>i</m:mi>

                    <m:mo>,</m:mo>

                    <m:mi>j</m:mi>

                    <m:mo stretchy="false">)</m:mo>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>. ]</para>
        </listitem>
      </orderedlist>

      <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class
const_View, typename Block&gt; T <emphasis role="bold">alltrue</emphasis>(const_View&lt;T, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have T the
            same as bool and <type>const_View</type> the same as
            <type>const_Vector</type> or <type>const_Matrix</type> . An
            implementation is permitted to prevent instantiation for other
            choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>If T is bool, the result of the application of accumulation
            operator land with base value !(T()) applied to v . Otherwise, the
            result of the application of accumulation operator band with base
            value ~(T()) applied to v .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_valltrue_bl and vsip_malltrue_bl.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">anytrue</emphasis>(const_View&lt;T, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have T the
            same as bool and const_View the same as const_Vector or
            const_Matrix . An implementation is permitted to prevent
            instantiation for other choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>If T is bool, the result of the application of accumulation
            operator lor with base value T() applied to v . Otherwise, the
            result of the application of accumulation operator bor with base
            value T() applied to v .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_vanytrue_bl and vsip_manytrue_bl.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">meanval</emphasis>(const_View&lt;T, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have T the
            same as scalar_f or cscalar_f and const_View the same as
            const_Vector or const_Matrix . An implementation is permitted to
            prevent instantiation for other choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The result of the application of accumulation operator add
            with base value T() applied to v divided by v .size().</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_vmeanval_f, vsip_mmeanval_f, vsip_cvmeanval_f, and
            vsip_cmmeanval_f. Users should be aware of the types in the
            division: T / v.size() .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">meansqval</emphasis>(const_View&lt;T, Block&gt; v) VSIP_NOTHROW; 
template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">meansqval</emphasis>(const_View&lt;complex&lt;T&gt;, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have T the
            same as scalar_f or cscalar_f and const_View the same as
            const_Vector or const_Matrix . An implementation is permitted to
            prevent instantiation for other choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Let set <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> contain, for every value val in v, mag(val) *
            mag(val). Returns the result of the application of accumulation
            operator add with base value T() applied to the set
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> divided by v.size().</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_vmeansqval_f, vsip_mmeansqval_f, vsip_cvmeansqval_f, and
            vsip_cmmeansqval_f. Users should be aware of the types in the
            division: T / v.size() .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">sumval</emphasis>(const_View&lt;T, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have T the
            same as scalar_f, scalar_i, cscalar_f, or cscalar_i and const_View
            the same as const_Vector or const_Matrix . An implementation is
            permitted to prevent instantiation for other choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The result of the application of accumulation operator add
            with base value T() .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_vsumval_f, vsip_msumval_f, vsip_vsumval_i, vsip_msumval_i,
            vsip_cvsumval_i, vsip_cmsumval_i, vsip_cvsumval_f, and
            vsip_cmsumval_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;template &lt;typename, typename&gt; class const_View, typename Block&gt; 
length_type <emphasis role="bold">sumval</emphasis>(const_View&lt;bool, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have
            const_View the same as const_Vector or const_Matrix . An
            implementation is permitted to prevent instantiation for other
            choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of true values in v .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_vsumval_bl and vsip_msumval_bl.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">sumsqval</emphasis>(const_View&lt;T, Block&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have T the
            same as scalar_f and const_View the same as const_Vector or
            const_Matrix . An implementation is permitted to prevent
            instantiation for other choices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>Let set <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> contain, for every value val in v, val * val .
            Returns the result of the application of accumulation operator add
            with base value T() applied to the set <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to the VSIPL functions
            vsip_vsumsqval_f and vsip_msumsqval_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.fns.reductidx">
      <title>Reduction functions also returning indices</title>

      <titleabbrev>math.fns.reductidx</titleabbrev>

      <orderedlist>
        <listitem>
          <para>These reduction functions return both a scalar value and its
          corresponding index in the given view.</para>

          <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">maxval</emphasis>(const_View&lt;T, Block&gt; v, Index&lt;const_View&lt;T, Block&gt;::dim&gt;&amp; idx) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T
                the same as scalar_f and const_View the same as const_Vector
                or const_Matrix . An implementation is permitted to prevent
                instantiation for other choices.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Postconditions:</term>

              <listitem>
                <para>idx is the lexicographically smallest
                Index&lt;const_View&lt;T, Block&gt;::dim&gt; such that
                v.get(idx[0], ..., idx[const_View&lt;T, Block&gt;::dim-1]) ==
                res.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The result res of the application of accumulation
                operator max with base value T() .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vmaxval_f and vsip_mmaxval_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T 
<emphasis role="bold">maxmgsqval</emphasis>(const_View&lt;complex&lt;T&gt;, Block&gt; v, Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;&amp; idx) 
  VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T
                the same as scalar_f and const_View the same as const_Vector
                or const_Matrix . An implementation is permitted to prevent
                instantiation for other choices.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Postconditions:</term>

              <listitem>
                <para>idx is the lexicographically smallest
                Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;
                such that v.get(idx[0], ...,
                idx[const_View&lt;complex&lt;T&gt;, Block&gt;::dim-1]) ==
                res.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Let <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> contain, for every value val in v,
                mag(val) * mag(val) . Return the result res of the application
                of accumulation operator max with base value T() applied to
                the set <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vmaxmgsqval_f and vsip_mmaxmgsqval_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">
maxmgval</emphasis>(const_View&lt;complex&lt;T&gt;, Block&gt; v, Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;&amp; idx) 
  VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T
                the same as scalar_f and const_View the same as const_Vector
                or const_Matrix . An implementation is permitted to prevent
                instantiation for other choices.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Postconditions:</term>

              <listitem>
                <para>idx is the lexicographically smallest
                Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;
                such that v.get(idx[0], ..., idx[View&lt;complex&lt;T&gt;,
                Block&gt;::dim-1]) == res.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Let <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> contain, for every value val in v,
                mag(val) . Return the result res of the application of
                accumulation operator max with base value T() applied to the
                set <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vmaxmgval_f and vsip_mmaxmgval_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">minval</emphasis>(const_View&lt;T, Block&gt; v, Index&lt;const_View&lt;T, Block&gt;::dim&gt;&amp; idx) VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T
                the same as scalar_f and const_View the same as const_Vector
                or const_Matrix . An implementation is permitted to prevent
                instantiation for other choices.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Postconditions:</term>

              <listitem>
                <para>idx is the lexicographically smallest
                Index&lt;const_View&lt;T, Block&gt;::dim&gt; such that
                v.get(idx[0], ..., idx[View&lt;T, Block&gt;::dim-1]) ==
                res.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>The result res of the application of accumulation
                operator min with base value T() .</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vminval_f and vsip_mminval_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T <emphasis role="bold">
minmgsqval</emphasis>(const_View&lt;complex&lt;T&gt;, Block&gt; v, Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;&amp; idx) 
  VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T
                the same as scalar_f and const_View the same as const_Vector
                or const_Matrix . An implementation is permitted to prevent
                instantiation for other choices.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Postconditions:</term>

              <listitem>
                <para>idx is the lexicographically smallest
                Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;
                such that v.get(idx[0], ...,
                idx[const_View&lt;complex&lt;T&gt;, Block&gt;::dim-1]) ==
                res.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Let <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> contain, for every value val in v,
                mag(val) * mag(val). Return the result res of the application
                of accumulation operator min with base value T() applied to
                the set <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vminmgsqval_f and vsip_mminmgsqval_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>

          <synopsis>template &lt;typename T, template &lt;typename, typename&gt; class const_View, typename Block&gt; 
T 
<emphasis role="bold">minmgval</emphasis>(const_View&lt;complex&lt;T&gt;, Block&gt; v, Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;&amp; idx) 
  VSIP_NOTHROW;</synopsis>

          <variablelist>
            <varlistentry>
              <term>Requires:</term>

              <listitem>
                <para>The only specializations which must be supported have T
                the same as scalar_f and const_View the same as const_Vector
                or const_Matrix . An implementation is permitted to prevent
                instantiation for other choices.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Postconditions:</term>

              <listitem>
                <para>idx is the lexicographically smallest
                Index&lt;const_View&lt;complex&lt;T&gt;, Block&gt;::dim&gt;
                such that v.get(idx[0], ...,
                idx[const_View&lt;complex&lt;T&gt;, Block&gt;::dim-1]) ==
                res.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Returns:</term>

              <listitem>
                <para>Let <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation> contain, for every value val in v,
                mag(val). Return the result res of the application of
                accumulation operator min with base value T() applied to the
                set <inlineequation>
                    <m:math>
                      <m:mstyle displaystyle="true">
                        <m:mrow>
                          <m:mi>S</m:mi>
                        </m:mrow>
                      </m:mstyle>
                    </m:math>
                  </inlineequation>.</para>
              </listitem>
            </varlistentry>

            <varlistentry>
              <term>Note:</term>

              <listitem>
                <para>Some specializations correspond to the VSIPL functions
                vsip_vminmgval_f and vsip_mminmgval_f.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </listitem>
      </orderedlist>
    </section>

    <section xml:id="math.fns.operators">
      <title>Operators</title>

      <titleabbrev>math.fns.operators</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Overloaded C++ operators provide synonyms for several VSIPL++
          functions. See <xref linkend="math_fn-real-operators-table"/> and
          <xref linkend="math_fn-real-operators-logical_table"/>. A listing
          for a function f incorporates all overloaded versions of f . The
          operator must obey all the restrictions of its synonym.</para>

          <table xml:id="math_fn-real-operators-table">
            <caption>Overloaded operators</caption>

            <thead>
              <tr>
                <th>function</th>

                <th>operator</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><function>add</function></td>

                <td><function>+</function></td>
              </tr>

              <tr>
                <td><function>div</function></td>

                <td><function>/</function></td>
              </tr>

              <tr>
                <td><function>mul</function></td>

                <td><function>*</function></td>
              </tr>

              <tr>
                <td><function>neg</function></td>

                <td>unary <function>-</function></td>
              </tr>

              <tr>
                <td><function>sub</function></td>

                <td>binary <function>-</function></td>
              </tr>

              <tr>
                <td><function>eq</function></td>

                <td><function>==</function></td>
              </tr>

              <tr>
                <td><function>ge</function></td>

                <td><function>&gt;=</function></td>
              </tr>

              <tr>
                <td><function>gt</function></td>

                <td><function>&gt;</function></td>
              </tr>

              <tr>
                <td><function>le</function></td>

                <td><function>&lt;=</function></td>
              </tr>

              <tr>
                <td><function>lt</function></td>

                <td><function>&lt;</function></td>
              </tr>

              <tr>
                <td><function>ne</function></td>

                <td><function>!=</function></td>
              </tr>

              <tr>
                <td><function>land</function></td>

                <td><function>&amp;&amp;</function></td>
              </tr>

              <tr>
                <td><function>band</function></td>

                <td><function>&amp;</function></td>
              </tr>

              <tr>
                <td><function>lnot</function></td>

                <td><function>!</function></td>
              </tr>

              <tr>
                <td><function>bnot</function></td>

                <td><function>~</function></td>
              </tr>

              <tr>
                <td><function>lor</function></td>

                <td><function>||</function></td>
              </tr>

              <tr>
                <td><function>bor</function></td>

                <td><function>|</function></td>
              </tr>
            </tbody>
          </table>
        </listitem>

        <listitem>
          <para>Overloaded C++ assignment operators provide syntax combining
          an arithmetic operation and an assignment to the left operand. See
          <xref linkend="math_fn-assignment-operators-table"/> for a summary.
          These are specified in <xref linkend="view.vector.assign"/>, <xref
          linkend="view.matrix.assign"/>, and <xref
          linkend="view.tensor.assign"/>.</para>

          <table xml:id="math_fn-assignment-operators-table">
            <caption>Overloaded assignment operators</caption>

            <thead>
              <tr>
                <th>operation</th>

                <th>operator</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><para>add and assign</para></td>

                <td><function>+=</function></td>
              </tr>

              <tr>
                <td><para>div and assign</para></td>

                <td><function>/=</function></td>
              </tr>

              <tr>
                <td><para>mul and assign</para></td>

                <td><function>*=</function></td>
              </tr>

              <tr>
                <td><para>sub and assign</para></td>

                <td><function>-=</function></td>
              </tr>

              <tr>
                <td><para>&amp; and assign</para></td>

                <td><function>&amp;=</function></td>
              </tr>

              <tr>
                <td><para>| and assign</para></td>

                <td><function>|=</function></td>
              </tr>

              <tr>
                <td><para>^ and assign</para></td>

                <td><function>^=</function></td>
              </tr>
            </tbody>
          </table>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> Some overloaded logical C++
          operators differ according to their parameter types. See <xref
          linkend="math_fn-real-operators-logical_table"/> for a
          summary.</para>

          <table xml:id="math_fn-real-operators-logical_table">
            <caption>Overloaded logical operators differing according to
            parameter types</caption>

            <thead>
              <tr>
                <th>function</th>

                <th>operator</th>
              </tr>
            </thead>

            <tbody>
              <tr>
                <td><para>lxor, bxor</para></td>

                <td><function>^</function></td>
              </tr>
            </tbody>
          </table>

          <para>]</para>
        </listitem>
      </orderedlist>

      <synopsis>template &lt;typename T1, typename T2&gt; 
typename Promotion&lt;T1, T2&gt;::type <emphasis role="bold">operator^ </emphasis>(T1 a, T2 b) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are
            operator <code>^</code> &lt;bool, bool&gt; and operator^
            &lt;scalar_i, scalar_i&gt;. An implementation is permitted to
            prevent instantiation of operator^ &lt;T1, T2&gt; for other
            choices of T1 and T2.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>lxor(a, b) if T1 and T2 are both bool . Otherwise,
            bxor&lt;T1, T2&gt;(a, b) .</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section xml:id="math.matvec">
    <title>Matrix and Vector Operations</title>

    <titleabbrev>math.matvec</titleabbrev>

    <xi:include href="code/math-matvec.hpp"/>

    <orderedlist>
      <listitem>
        <para>Behavior for domain, range, overflow, and underflow errors and
        for undefined values conforms to VSIPL, i.e., the result is undefined behavior.</para>
      </listitem>
    </orderedlist>

    <section xml:id="math.matvec.dot">
      <title>Dot products</title>

      <titleabbrev>math.matvec.dot</titleabbrev>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
typename Promotion&lt;complex&lt;T0&gt;, complex&lt;T1&gt; &gt;::type <emphasis
          role="bold">
cvjdot</emphasis>(const_Vector&lt;complex&lt;T0&gt;, Block0&gt; v,
       const_Vector&lt;complex&lt;T1&gt;, Block1&gt; w) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported has T0 and
            T1 both equal to scalar_f . An implementation is permitted to
            prevent instantiation of cvjdot&lt;T0, T1, Block0, Block1&gt; for
            other choices of T0 and T1 . v and w must be
            element-conformant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The conjugate dot product <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:msup>
                      <m:mi>v</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>

                    <m:msup>
                      <m:mi>w</m:mi>

                      <m:mo>*</m:mo>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Using T0 or T1 equal to scalar_f implies a
            const_Vector&lt;complex&lt;scalar_f&gt;, Block&gt; argument. Some
            specializations correspond to VSIPL function vsip_cvjdot_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
typename Promotion&lt;T0, T1&gt;::type 
<emphasis role="bold">dot</emphasis>(const_Vector&lt;T0, Block0&gt; v, const_Vector&lt;T1, Block1&gt; w) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported have both
            T0 and T1 equal to either scalar_f or cscalar_f . An
            implementation is permitted to prevent instantiation of dot&lt;T0,
            T1, Block0, Block1&gt; for other choices of T0 and T1 . v and w
            must be element-conformant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The inner dot product <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:msup>
                      <m:mi>v</m:mi>

                      <m:mi>T</m:mi>
                    </m:msup>

                    <m:mi>w</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vdot_f and vsip_cvdot_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.transpose">
      <title>Matrix transpositions</title>

      <titleabbrev>math.matvec.transpose</titleabbrev>

      <synopsis>template &lt;typename T, typename Block&gt; 
const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">trans</emphasis>(const_Matrix&lt;T, Block&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported has T equal
            to scalar_f or cscalar_f . An implementation is permitted to
            prevent instantiation for other choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The transposition of <inlineequation>
                <m:math display="inline">
                  <m:mi>m</m:mi>
                </m:math>
              </inlineequation>, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mi>m</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mtrans_f and vsip_cmtrans_f. The returned matrix’s block type
            is not necessarily equal to Block . VSIPL functions support
            in-place transposition on square matrixes, but VSIPL++ does not
            support in-place transposition. See <xref
            linkend="view.matrix.subviews"/> for an alternate transposition
            implementation.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, typename Block&gt;
const_Matrix&lt;complex&lt;T&gt;, <emphasis>unspecified</emphasis>&gt;
<emphasis role="bold">herm</emphasis>(const_Matrix&lt;complex&lt;T&gt;, Block&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specialization which must be supported has T equal
            to scalar_f . An implementation is permitted to prevent
            instantiation for other choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The Hermitian (conjugate transpose) of <inlineequation>
                <m:math display="inline">
                  <m:mi>m</m:mi>
                </m:math>
              </inlineequation>, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mi>m</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Using T equal to scalar_f implies a
            const_Matrix&lt;complex&lt;scalar_f&gt;, Block&gt; argument. Some
            specializations correspond to VSIPL function vsip_cmherm_f. The
            returned matrix’s block type is not necessarily equal to Block .
            VSIPL functions support in-place transposition on square matrixes,
            but VSIPL++ does not support in-place transposition.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.kron">
      <title>Kronecker tensor product</title>

      <titleabbrev>math.matvec.kron</titleabbrev>

      <synopsis>template &lt;typename T0, typename T1, typename T2, 
          template &lt;typename, typename&gt; class const_View,
          typename Block1, typename Block2&gt; 
const_Matrix&lt;typename Promotion&lt;T0, typename Promotion&lt;T1, T2&gt;::type&gt;::type, <emphasis>unspecified</emphasis>&gt; <emphasis
          role="bold">
kron</emphasis>(T0 alpha, const_View&lt;T1, Block1&gt; v, const_View&lt;T2, Block2&gt; w) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0, T1, and T2 all the same and equal to either scalar_f or
            cscalar_f and const_View equal to either const_Vector or
            const_Matrix . An implementation is permitted to prevent
            instantiation for other choices of T0, T1, T2, and View .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The alpha-scaled Kronecker tensor product of v and w
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>For const_View equal to const_Vector, the resulting matrix
            has m rows and n columns if <code>v.size() == n &amp;&amp;
            w.size() == m</code> . For const_View equal to const_Matrix, the
            resulting matrix has <code>v.size(0) * w.size(0)</code> rows and
            <code>v.size(1) * w.size()</code> columns.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vkron_f, vsip_cvkron_f, vsip_mkron_f, and vsip_cmkron_f. For
            a mathematical description of the product, see the VSIPL specification.
	    The returned matrix’s block’s type is not necessarily equal to either 
	    Block1 or Block2.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.outer">
      <title>Outer product</title>

      <titleabbrev>math.matvec.outer</titleabbrev>

      <synopsis>template &lt;typename T0, typename T1, typename T2, typename Block1, typename Block2&gt; 
const_Matrix&lt;typename Promotion&lt;T0, typename Promotion&lt;T1, T2&gt;::type&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">outer</emphasis>(T0 alpha, const_Vector&lt;T1, Block1&gt; v, const_Vector&lt;T2, Block2&gt; w) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0, T1, and T2 all the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0, T1, and T2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The alpha-scaled outer product of v and w . If both T1 and
            T2 are cscalar_f, the outer product is <inlineequation>
                <m:math>
                  <m:msup>
                    <m:mi>w</m:mi>

                    <m:mi>H</m:mi>
                  </m:msup>
                </m:math>
              </inlineequation> so <inlineequation>
                <m:math>
                  <m:mtext>alpha</m:mtext>

                  <m:mo>*</m:mo>

                  <m:mi>v</m:mi>

                  <m:msup>
                    <m:mi>w</m:mi>

                    <m:mi>H</m:mi>
                  </m:msup>
                </m:math>
              </inlineequation> is returned. Otherwise, the outer product is
            <inlineequation>
                <m:math>
                  <m:mi>v</m:mi>

                  <m:msup>
                    <m:mi>w</m:mi>

                    <m:mi>T</m:mi>
                  </m:msup>
                </m:math>
              </inlineequation> so <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mtext>alpha</m:mtext>

                      <m:mo>*</m:mo>

                      <m:mi>v</m:mi>

                      <m:msup>
                        <m:mi>w</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is returned.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has m rows and n columns if v.size() ==
            m &amp;&amp; w.size() == n .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vouter_f and vsip_cvouter_f. For a mathematical description
            of the product, see the VSIPL specification. The returned matrix’s 
	    block’s type is not necessarily equal to either Block1 or Block2.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.product">
      <title>Matrix products</title>

      <titleabbrev>math.matvec.product</titleabbrev>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Matrix&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">prod</emphasis>(const_Matrix&lt;T0, Block0&gt; m0, const_Matrix&lt;T1, Block1&gt; m1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . m0.size(1) ==
            m1.size(0) .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix product of m0 and m1 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has m rows and n columns if m0.size(0)
            == m &amp;&amp; m1.size(1) == n.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mprod_f and vsip_cmprod_f. The returned matrix’s block’s type
            is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Vector&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">prod</emphasis>(const_Matrix&lt;T0, Block0&gt; m, const_Vector&lt;T1, Block1&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . m.size(1) ==
            v.size() .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix-vector product of m and v .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting vector res has res.size() == m.size(0)
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mvprod_f and vsip_cmvprod_f. The returned matrix’s block’s
            type is not necessarily equal to Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Vector&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; <emphasis
          role="bold">
prod</emphasis>(const_Vector&lt;T0, Block0&gt; v, const_Matrix&lt;T1, Block1&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to scalar_f or cscalar_f
            . An implementation is permitted to prevent instantiation for
            other choices of T0 and T1 . m.size(0) == v.size() .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The vector-matrix product of v and m, i.e., <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mi>v</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mi>m</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting vector res has <code>res.size() ==
            m.size(1)</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vmprod_f and vsip_cvmprod_f. The returned matrix’s block’s
            type is not necessarily equal to Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Matrix&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; <emphasis
          role="bold">
prod3</emphasis>(const_Matrix&lt;T0, Block0&gt; m0, const_Matrix&lt;T1, Block1&gt; m1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . m0.size(0) ==
            m0.size(1) == m1.size(0) == 3 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix product of m0 and m1 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has three rows and n columns if
            m1.size(1) == n .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mprod3_f and vsip_cmprod3_f. The returned matrix’s block’s
            type is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Vector&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">prod3</emphasis>(const_Matrix&lt;T0, Block0&gt; m0, const_Vector&lt;T1, Block1&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . <code>m0.size(0) ==
            m0.size(1) == v.size() == 3</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix-vector product of m0 and v .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting vector has three rows.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mvprod3_f and vsip_cmvprod3_f. The returned matrix’s block’s
            type is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Matrix&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">prod4</emphasis>(const_Matrix&lt;T0, Block0&gt; m0, const_Matrix&lt;T1, Block1&gt; m1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . <code>m0.size(0) ==
            m0.size(1) == m1.size(0) == 4</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix product of m0 and m1 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has four rows and n columns if
            m1.size(1) == n .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mprod4_f and vsip_cmprod4_f. The returned matrix’s block’s
            type is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Vector&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">prod4</emphasis>(const_Matrix&lt;T0, Block0&gt; m0, const_Vector&lt;T1, Block1&gt; v) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . <code>m0.size(0) ==
            m0.size(1) == v.size() == 4</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix-vector product of m0 and v .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting vector has four rows.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mvprod4_f and vsip_cmvprod4_f. The returned matrix’s block’s
            type is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Matrix&lt;typename Promotion&lt;complex&lt;T0&gt;, complex&lt;T1&gt; &gt;::type, <emphasis>unspecified</emphasis>&gt;
<emphasis role="bold">prodh</emphasis>(const_Matrix&lt;complex&lt;T0&gt;, Block0&gt; m0, const_Matrix&lt;complex&lt;T1&gt;, Block1&gt; m1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both equal to scalar_f . An implementation is
            permitted to prevent instantiation for other choices of T0 and T1
            . m0.size(1) == m1.size(1) .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix product of m0 and the Hermitian of m1, i.e.,
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mtext>m0</m:mtext>

                    <m:mo>×</m:mo>

                    <m:msup>
                      <m:mtext>m1</m:mtext>

                      <m:mi>H</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has m rows and n columns if m0.size(0)
            == m &amp;&amp; m1.size(0) == n.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Using T0 or T1 equal to scalar_f implies a
            const_Matrix&lt;complex&lt;scalar_f&gt;, Block&gt; argument. Some
            specializations correspond to VSIPL function vsip_cmprodh_f. The
            returned matrix’s block’s type is not necessarily equal to either
            Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Matrix&lt;typename Promotion&lt;complex&lt;T0&gt;, complex&lt;T1&gt; &gt;::type, <emphasis>unspecified</emphasis>&gt;
<emphasis role="bold">prodj</emphasis>(const_Matrix&lt;complex&lt;T0&gt;, Block0&gt; m0,
      const_Matrix&lt;complex&lt;T1&gt;, Block1&gt; m1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both equal to scalar_f . An implementation is
            permitted to prevent instantiation for other choices of T0 and T1
            . m0.size(1) == m1.size(0) .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix product of m0 and the conjugate of m1, i.e.,
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mtext>m0</m:mtext>

                    <m:mo>×</m:mo>

                    <m:msup>
                      <m:mtext>m1</m:mtext>

                      <m:mo>*</m:mo>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has m rows and n columns if m0.size(0)
            == m &amp;&amp; m1.size(1) == n.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Using T0 or T1 equal to scalar_f implies a
            const_Matrix&lt;complex&lt;scalar_f&gt;, Block&gt; argument. Some
            specializations correspond to VSIPL function vsip_cmprodj_f. The
            returned matrix’s block’s type is not necessarily equal to either
            Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename Block0, typename Block1&gt; 
const_Matrix&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">prodt</emphasis>(const_Matrix&lt;T0, Block0&gt; m0, const_Matrix&lt;T1, Block1&gt; m1) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both the same and equal to either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation for other choices of T0 and T1 . m0.size(1) ==
            m1.size(1) .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The matrix product of m0 and the transpose of m1, i.e.,
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mtext>m0</m:mtext>

                    <m:mo>×</m:mo>

                    <m:msup>
                      <m:mtext>m1</m:mtext>

                      <m:mi>T</m:mi>
                    </m:msup>
                  </m:mrow>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The resulting matrix has m rows and n columns if
            <code>m0.size(0) == m &amp;&amp; m1.size(0) == n</code>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_mprodt_f and vsip_cmprodt_f. The returned matrix’s block is
            not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.gem">
      <title>Generalized Matrix operations</title>

      <titleabbrev>math.matvec.gem</titleabbrev>

      <orderedlist>
        <listitem>
          <para>Generalized matrix operations include computing the
          generalized product of two matrices with accumulation and
          calculating the matrix sum.</para>
        </listitem>

        <listitem>
          <para>If OpX is a mat_op_type value and X is a Matrix, let OpX(X)
          denote the matrix resulting from applying the mat_op_type operation
          to X . For example, mat_trans(X) denotes the matrix transpose of X
          .</para>
        </listitem>

        <listitem>
          <para>mat_ntrans indicates no matrix operation. mat_trans indicates
          matrix transposition. mat_herm indicates the Hermitian conjugate.
          mat_conj indicates element-wise complex conjugation.</para>
        </listitem>
      </orderedlist>

      <synopsis>template &lt;mat_op_type OpA, mat_op_type OpB, 
          typename T0, typename T1, typename T2, typename T3, typename T4, typename Block1,
          typename Block2, typename Block4&gt; 
void <emphasis role="bold">gemp</emphasis>(T0 alpha, const_Matrix&lt;T1, Block1&gt; A, const_Matrix&lt;T2, Block2&gt; B, 
          T3 beta, Matrix&lt;T4, Block4&gt; C) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>OpA must equal mat_ntrans or mat_trans unless T1 is a
            complex type. OpB must equal mat_ntrans or mat_trans unless T2 is
            a complex type. OpA(A) and OpB(B) must be product-conformant.
            OpA(A).size(0) == C.size(0) . OpB(B).size(1) == C.size(1) .
            C.block() must not overlap either A.block() or B.block() . The
            only specializations which must be supported are those having T0,
            T1, T2, T3, and T4 all equal and equaling either scalar_f or
            cscalar_f . An implementation is permitted to prevent
            instantiation with other template arguments.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Equivalent to C = alpha * OpA(A) OpB(B) + beta * C.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_gemp_f and vsip_cgemp_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type OpA, 
          typename T0, typename T1, typename T3, typename T4, 
          typename Block1, typename Block4&gt; 
void <emphasis role="bold">gems</emphasis>(T0 alpha, const_Matrix&lt;T1, Block1&gt; A, T3 beta, Matrix&lt;T4, Block4&gt; C) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>OpA must equal mat_ntrans or mat_trans unless T1 is a
            complex type. OpA(A) and C must be element-conformant. C.block()
            must not overlap A.block() . The only specializations which must
            be supported are those having T0, T1, T3, and T4 all equal and
            equaling either scalar_f or cscalar_f . An implementation is
            permitted to prevent instantiation with other template
            arguments.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Equivalent to C = alpha * OpA(A) + beta * C .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_gems_f and vsip_cgems_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.vmmul">
      <title>Vector-Matrix products</title>

      <titleabbrev>math.matvec.vmmul</titleabbrev>

      <synopsis>template &lt;dimension_type d, typename T0, typename T1, typename Block0, typename Block1&gt; 
Matrix&lt;typename Promotion&lt;T0, T1&gt;::type, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">vmmul</emphasis>(const_Vector&lt;T0, Block0&gt; v, const_Matrix&lt;T1, Block1&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0 and T1 both equal to scalar_f, both equal to cscalar_f,
            or T0 equal to scalar_f and T1 equal to cscalar_f . An
            implementation is permitted to prevent instantiation for other
            choices of T0 and T1 . <code>v.size() == m.size(0)</code> if d ==
            1 .<code> v.size() == m.size(1)</code> if d == 0 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The element-wise multiplication of m and a replication of v.
            If d == 0, the replication of v is a matrix element-conformant
            with m and having each row equal to v. If d == 1, the replication
            of v is a matrix element-conformant with m and having each column
            equal to v.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vmmul_f, vsip_cvmmul_f, and vsip_rvcmmul_f. The returned
            matrix’s block is not necessarily equal to either Block0 or
            Block1.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.matvec.misc">
      <title>Miscellaneous functions</title>

      <titleabbrev>math.matvec.misc</titleabbrev>

      <synopsis>template &lt;dimension_type d, typename T0, typename T1, 
          template &lt;typename, typename&gt; class const_View, 
          template &lt;typename, typename&gt; class View, typename Block0, typename Block1&gt; 
void <emphasis role="bold">cumsum</emphasis>(const_View&lt;T0, Block0&gt; v, View&lt;T1, Block1&gt; w) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having const_View and View the same as const_Vector and Vector or
            const_Matrix and Matrix, respectively. Also, these specializations
            also have T0 and T1 equal scalar_f, scalar_i, cscalar_f, or
            cscalar_i . An implementation is permitted to prevent
            instantiation for other choices of View, T0, and T1 . v and w must
            be element-conformant. Block1 must be modifiable. Values with type
            T0 must be assignable to type T1 . v.block() and w.block() must be
            the same or not overlap.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>w has values equaling the cumulative sum of values in v . If
            View is Vector, d is ignored and, for 0 &lt;= i &lt; v.size(),
            w.get(i) equals the sum over 0 &lt;= j &lt;= i of v.get(j) . If
            View is Matrix and d == 0, then, for 0 &lt;= m &lt; v.size(0) and
            0 &lt;= i &lt; v.size(1), w.get(m, i) equals the sum over 0 &lt;=
            j &lt;= i of v.get(m, j) . If View is Matrix and d == 1, then, for
            0 &lt;= i &lt; v.size(0) and 0 &lt;= n &lt; v.size(1), w.get(i, n)
            equals the sum over 0 &lt;= j &lt;= i of v.get(j, n) .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vcumsum_f, vsip_vcumsum_i, vsip_cvcumsum_f, vsip_cvcumsum_i,
            vsip_mcumsum_f, vsip_mcumsum_i, vsip_cmcumsum_f, and
            vsip_cmcumsum_iy.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T0, typename T1, typename T2, typename T3, typename Block0, typename Block1&gt; 
T1 <emphasis role="bold">
modulate</emphasis>(const_Vector&lt;T0, Block0&gt; v, T1 nu, T2 phi, Vector&lt;complex&lt;T3&gt;, Block1&gt; w) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The only specializations which must be supported are those
            having T0, T1, T2, and T3 all scalar_f or alternatively T0 the
            same as cscalar_f and T1, T2, and T3 all scalar_f . An
            implementation is permitted to prevent instantiation for other
            choices of T0, T1, T2, and T3 . v and w must be
            element-conformant. Block1 must be modifiable. T0, T1, T2, and T3
            must be such that t0 * cos(k * t1 + t2) can be assigned to a T3
            value, where values t0, k, t1, and t2 have types T0, index_type,
            T1, and T2, respectively. v.block() and w.block() must either be
            the same or not overlap.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>For 0 &lt;= i &lt; v.size(), w.get(i) has a value equaling
            the product of v.get(i) and the exponential of the product of
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>i</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> (<inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msqrt>
                        <m:mrow>
                          <m:mo>-</m:mo>

                          <m:mn>1</m:mn>
                        </m:mrow>
                      </m:msqrt>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>) and i * nu + phi .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>v.size() * nu + phi .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Some specializations correspond to VSIPL functions
            vsip_vmodulate_f and vsip_cvmodulate_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>

  <section xml:id="math.solvers">
    <title>Linear system solvers</title>

    <titleabbrev>math.solvers</titleabbrev>

    <orderedlist>
      <listitem>
        <para>These functions and classes solve linear systems and also
        perform singular value decomposition.</para>
      </listitem>

      <listitem>
        <para>[<emphasis>Note: </emphasis> Many of these solvers throw
        exceptions, e.g., std::bad_alloc and computation_error, to indicate
        memory allocation and computation errors. ]</para>

        <para>Header <emphasis>&lt;vsip/solvers.hpp&gt;</emphasis>
        synopsis</para>

        <xi:include href="code/solvers.hpp"/>
      </listitem>
    </orderedlist>

    <section xml:id="math.solvers.covsol">
      <title>Covariance linear system solver</title>

      <titleabbrev>math.solvers.covsol</titleabbrev>

      <synopsis>template &lt;typename T, typename Block0, typename Block1&gt;
const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">covsol</emphasis>(Matrix&lt;T, Block0&gt; m0, const_Matrix&lt;T, Block1&gt; m1) 
  VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m0.size(0) &gt;= m0.size(1) . m0.size(1) == m1.size(0) . The
            rank of m0 must equal m0.size(1) . m0 and m1 must not overlap. The
            only required specializations which must be supported are for T
            equal to either scalar_f or cscalar_f . An implementation is
            permitted to prevent instantiations for other choices of T .
            Block0 must be modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The solution X to the covariance linear system
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mtext>m0</m:mtext>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mtext>m0</m:mtext>

                      <m:mi>X</m:mi>

                      <m:mo>=</m:mo>

                      <m:mtext>m1</m:mtext>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> if T is scalar_f . The solution X to the
            covariance linear system <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mtext>m0</m:mtext>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mtext>m0</m:mtext>

                      <m:mi>X</m:mi>

                      <m:mo>=</m:mo>

                      <m:mtext>m1</m:mtext>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> if T is cscalar_f .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The returned matrix is element-conformant with m1 . m0 may
            have been overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon a memory allocation error and
            computation_error if m0 does not have full column rank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Temporary workspace may be allocated, which may result in
            nondeterministic execution time. As an alternative, use the QR
            routines. This function corresponds to VSIPL functions
            vsip_covsol_f and vsip_ccovsol_f. The returned matrix’s block’s
            type is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, typename Block0, typename Block1, typename Block2&gt; 
Matrix&lt;T, Block2&gt; 
<emphasis role="bold">covsol</emphasis>(Matrix&lt;T, Block0&gt; m0, const_Matrix&lt;T, Block1&gt; m1, Matrix&lt;T, Block2&gt; m2)
  VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>m0.size(0) &gt;= m0.size(1)</code> . <code>m0.size(1)
            == m1.size(0)</code> . The rank of m0 must equal m0.size(1) . m1
            and m2 are element-conformant. m0, m1, and m2 must not overlap.
            Block0 and Block2 must be modifiable. The only required
            specializations which must be supported are for T equal to either
            scalar_f or cscalar_f . An implementation is permitted to prevent
            instantiations for other choices of T .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>The solution X to the covariance linear system
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mtext>m0</m:mtext>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mtext>m0</m:mtext>

                      <m:mi>X</m:mi>

                      <m:mo>=</m:mo>

                      <m:mi>m1</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is stored in m2 if T is scalar_f . The
            solution X to the covariance linear system <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mtext>m0</m:mtext>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mtext>m0</m:mtext>

                      <m:mi>X</m:mi>

                      <m:mo>=</m:mo>

                      <m:mtext>m1</m:mtext>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is stored in m2 if T is cscalar_f .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>m2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m0 may have been overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon a memory allocation error and
            computation_error if m0 does not have full column rank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Temporary workspace may be allocated, which may result in
            nondeterministic execution time. As an alternative, use the QR
            routines. This function corresponds to VSIPL functions
            vsip_covsol_f and vsip_ccovsol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.solvers.llsqsol">
      <title>Linear least squares solver</title>

      <titleabbrev>math.solvers.llsqsol</titleabbrev>

      <synopsis>template &lt;typename T, typename Block0, typename Block1&gt;
Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">
llsqsol</emphasis>(Matrix&lt;T, Block0&gt; m0, const_Matrix&lt;T, Block1&gt; m1) 
  VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>m0 .size(0) &gt;= m0.size(1)</code>. <code>m0.size(0)
            == m1.size(0)</code> . The rank of m0 must equal m0.size(1) . m0
            and m1 must not overlap. The only required specializations which
            must be supported are for T equal to either scalar_f or cscalar_f
            . An implementation is permitted to prevent instantiations for
            other choices of T . Block0 must be modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The solution X to the linear least squares problem
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:msub>
                      <m:mo>min</m:mo>

                      <m:mi>X</m:mi>
                    </m:msub>

                    <m:mo>⁡</m:mo>

                    <m:msub>
                      <m:mrow>
                        <m:mo>||</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mi>m0</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:mi>X</m:mi>
                          </m:mrow>

                          <m:mo>-</m:mo>

                          <m:mi>m1</m:mi>
                        </m:mrow>

                        <m:mo>||</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation>.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The returned matrix has m0.size(1) rows and m1.size(1)
            columns. m0 may have been overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon a memory allocation error and
            computation_error if m0 does not have full column rank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Temporary workspace may be allocated, which may result in
            nondeterministic execution time. As an alternative, use the QR
            routines. This function corresponds to VSIPL functions
            vsip_llsqsol_f and vsip_cllsqsol_f. The returned matrix’s block’s
            type is not necessarily equal to either Block0 or Block1 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, typename Block0, typename Block1, typename Block2&gt; 
Matrix&lt;T, Block2&gt; <emphasis role="bold">
llsqsol</emphasis>(Matrix&lt;T, Block0&gt; m0, const_Matrix&lt;T, Block1&gt; m1, Matrix&lt;T, Block2&gt; m2)
  VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m0.size(0) &gt;= m0.size(1) . m0.size(0) == m1.size(0) . The
            rank of m0 must equal m0.size(1) . <code>m2.size(0) ==
            m0.size(1)</code> . <code>m2.size(1) == m1.size(1)</code> . m0,
            m1, and m2 must not overlap. Block0 and Block2 must be modifiable.
            The only required specializations which must be supported are for
            T equal to either scalar_f or cscalar_f . An implementation is
            permitted to prevent instantiations for other choices of T
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>The solution X to the linear least squares problem
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:msub>
                      <m:mo>min</m:mo>

                      <m:mi>X</m:mi>
                    </m:msub>

                    <m:mo>⁡</m:mo>

                    <m:msub>
                      <m:mrow>
                        <m:mo>||</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mi>m0</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:mi>X</m:mi>
                          </m:mrow>

                          <m:mo>-</m:mo>

                          <m:mi>m1</m:mi>
                        </m:mrow>

                        <m:mo>||</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation> is placed in m2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>m2 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m0 may have been overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon a memory allocation error and
            computation_error if m0 does not have full column rank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Temporary workspace may be allocated, which may result in
            nondeterministic execution time. As an alternative, use the QR
            routines. This function corresponds to VSIPL functions
            vsip_llsqsol_f and vsip_cllsqsol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.solvers.toeplitz">
      <title>Toeplitz linear system solver</title>

      <titleabbrev>math.solvers.toeplitz</titleabbrev>

      <synopsis>template &lt;typename T, typename Block0, typename Block1, typename Block2&gt; 
const_Vector&lt;T, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">toepsol</emphasis>(const_Vector&lt;T, Block0&gt; t, const_Vector&lt;T, Block1&gt; b, Vector&lt;T, Block2&gt; w)
  VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The Toeplitz matrix T formed from t must have full rank and
            be positive definite.<code> t.size() == b.size() ==
            w.size()</code>. w’s block may not overlap t’s block nor b’s
            block. The only required specializations which must be supported
            are for T equal to either scalar_f or cscalar_f . An
            implementation is permitted to prevent instantiations for other
            choices of T . Block2 must be a modifiable type.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The solution X to the Toeplitz linear system <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>T</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi>X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where t specifies the Toeplitz matrix T . The
            Toeplitz linear system is real symmetric if T is scalar_f and is
            Hermitian if T is cscalar_f .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The returned vector has t.size() entries.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon a memory allocation error and
            computation_error if the Toeplitz matrix T does not have full
            column rank or is not positive definite.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>w might be used as a temporary workspace. This function
            corresponds to VSIPL functions vsip_toepsol_f and vsip_ctoepsol_f.
            For a mathematical description of the system, see the VSIPL 
	    specification. The returned
            vector’s block’s type is not necessarily equal to Block0, Block1,
            or Block2 .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename T, typename Block0, typename Block1, typename Block2, typename Block3&gt; 
Vector&lt;T, Block3&gt; 
<emphasis role="bold">toepsol</emphasis>(const_Vector&lt;T, Block0&gt; t, 
        const_Vector&lt;T, Block1&gt; b, 
        Vector&lt;T, Block2&gt; w, 
        Vector&lt;T, Block3&gt; answer) 
  VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>The Toeplitz matrix T formed from t must have full rank and
            be positive definite. <code>t.size() == b.size() == w.size() ==
            answer.size()</code>. The answer’s block must not overlap t’s
            block nor b’s block nor w’s block. w’s block may not overlap t’s
            block nor b’s block. w and answer must be modifiable. The only
            required specializations which must be supported are for T the
            equal to either scalar_f or cscalar_f . An implementation is
            permitted to prevent instantiations for other choices of T
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>The solution X to the Toeplitz linear system <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>T</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mi>X</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where t specifies the Toeplitz matrix T, is
            placed in answer . The Toeplitz linear system is real symmetric if
            T is scalar_f and is Hermitian if T is cscalar_f .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>answer .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The returned vector has t.size() entries.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon a memory allocation error and
            computation_error if the Toeplitz matrix T does not have full
            column rank or is not positive definite.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>w might be used as a temporary workspace. This function
            corresponds to VSIPL functions vsip_toepsol_f and
            vsip_ctoepsol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.solvers.lu">
      <title>LU linear system solver</title>

      <titleabbrev>math.solvers.lu</titleabbrev>

      <orderedlist>
        <listitem>
          <para>The template class lud uses LU (lower and upper triangular)
          decomposition to solve a linear system. The only specializations of
          lud which must be supported are lud&lt;scalar_f, RM&gt; and
          lud&lt;cscalar_f, RM&gt; for any return_mechanism_type value of RM .
          An implementation is permitted to prevent instantiation of lud&lt;T,
          RM&gt; for other choices of T .</para>
        </listitem>
      </orderedlist>

      <xi:include href="code/math-solvers-lu.hpp"/>

      <synopsis><emphasis role="bold">lud</emphasis>(length_type len) VSIP_THROW((std::bad_alloc));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>len &gt; 0 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs an lud object that will decompose len by len
            matrices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc indicating memory allocation for the returned
            lud object failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_lud_create_f and vsip_clud_create_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">length</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of rows in a decomposed matrix. The number of
            columns is the same.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>The returned value equals the required number of rows in the
            matrix given to decompose . This function corresponds to VSIPL
            functions vsip_lud_getattr_f and vsip_clud_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; bool <emphasis role="bold">decompose</emphasis>(Matrix&lt;T, Block&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be a square matrix with the same number of rows and
            columns and having full rank. The number of rows must equal
            this-&gt;length() . m must be modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Performs LU decomposition of m . The matrix m may be
            overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>false if the decomposition fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The matrix m may not be modified as long as its
            decomposition may be used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>The choice of using row interchanges or column interchanges
            is implementation dependent. This function corresponds to VSIPL
            functions vsip_lud_f and vsip_clud_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, typename Block&gt; const_Matrix&lt;T,<emphasis>unspecified</emphasis>&gt; <emphasis
          role="bold">
solve</emphasis>(const_Matrix&lt;T,Block&gt; b) VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>b.size(0) == this-&gt;length()</code> . A call to
            decompose for this object must have occurred. ReturnMechanism ==
            by_value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A matrix m containing the solution. If T == scalar_f and tr
            == mat_trans, m is the solution to <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi>A</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where A is the matrix given to the most
            recent decompose call for this object. If T == cscalar_f and tr ==
            mat_herm, m is the solution to <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi>A</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>. Otherwise, <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> is solved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m and b are element-conformant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the computation fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_lusol_f
            and vsip_clusol_f. The returned matrix’s block’s type is not
            necessarily equal to Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, typename Block1, typename Block2&gt;
bool <emphasis role="bold">solve</emphasis>(const_Matrix&lt;T,Block1&gt; b, Matrix&lt;T, Block2&gt; answer) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b.size(0) == length() . b and answer are element-conformant
            and must not overlap. A call to decompose for this object must
            have occurred. ReturnMechanism == by_reference. answer must be
            modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>A matrix m containing the solution is placed in answer . If
            T == scalar_f and tr == mat_trans, m is the solution to
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi>A</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where A is the matrix given to the most
            recent decompose call for this object. If T == cscalar_f and tr ==
            mat_herm, m is the solution to <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi>A</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>. Otherwise, <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> is solved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the computation succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_lusol_f
            and vsip_clusol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.solvers.cholesky">
      <title>Cholesky decomposition linear system solver</title>

      <titleabbrev>math.solvers.cholesky</titleabbrev>

      <orderedlist>
        <listitem>
          <para>The template class chold uses Cholesky decomposition to solve
          a linear system. The only specializations of chold which must be
          supported are chold&lt;scalar_f, RM&gt; and chold&lt;cscalar_f,
          RM&gt; for any return_mechanism_type value of RM . An implementation
          is permitted to prevent instantiation of chold&lt;T, RM&gt; for
          other choices of T .</para>

          <xi:include href="code/math-solvers-cholesky.hpp"/>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> enum mat_uplo indicates which
          half of a symmetric or Hermitian matrix is referenced. lower
          indicates the lower half of the matrix is referenced. upper
          indicates the upper half of the matrix is referenced. ]</para>
        </listitem>
      </orderedlist>

      <synopsis><emphasis role="bold">chold</emphasis>(mat_uplo uplo, length_type len) VSIP_THROW((std::bad_alloc));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>Positive len .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a chold object that will decompose len by len
            symmetric positive definite matrices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc indicating memory allocation for the returned
            chold object failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_chold_create_f and vsip_cchold_create_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">length</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of rows in a decomposed matrix. The number of
            columns is the same.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>The returned value equals the required number of rows in the
            matrix given to decompose for this object. This function
            corresponds to VSIPL functions vsip_chold_getattr_f and
            vsip_cchold_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>mat_uplo <emphasis role="bold">uplo</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>An indication whether the lower half or upper half of a
            decomposed matrix is referenced.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_chold_getattr_f and vsip_cchold_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; bool <emphasis role="bold">decompose</emphasis>(Matrix&lt;T, Block&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m must be a square matrix with the same number of rows and
            columns. If T is scalar_f, m must be symmetric positive definite.
            If T is cscalar_f, m must be Hermitian positive definite. The
            number of rows must equal length() . m must be modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Performs Cholesky decomposition of m . The matrix m may be
            overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>false if the decomposition fails. It will fail if a leading
            minor of m is not symmetric or Hermitian positive definite and the
            algorithm cannot complete.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The matrix m may not be modified as long as its
            decomposition may be used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_chold_f
            and vsip_cchold_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt;
const_Matrix&lt;T,<emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">solve</emphasis>(const_Matrix&lt;T,Block&gt; b) VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b.size(0) == length() . A call to decompose for this object
            must have occurred. ReturnMechanism == by_value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A constant matrix m containing the solution to
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where A is the matrix given to the most
            recent decompose call for this object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m and b are element-conformant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the most recent decompose call for this
            object failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_cholsol_f
            and vsip_ccholsol_f. The returned matrix’s block’s type is not
            necessarily equal to Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block, typename Block1&gt; 
bool <emphasis role="bold">solve</emphasis>(const_Matrix&lt;T,Block&gt; b, Matrix&lt;T, Block1&gt; answer) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b.size(0) == length() . A call to decompose must have
            occurred. b and answer are element-conformant and must not
            overlap. answer must be modifiable. ReturnMechanism ==
            by_reference .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>A matrix m containing the solution to <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>A</m:mi>

                      <m:mo>⁣</m:mo>

                      <m:mi>m</m:mi>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation>, where A is the matrix given to the most
            recent decompose call for this object, is placed in answer
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the computation succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_cholsol_f
            and vsip_ccholsol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.solvers.qr">
      <title>QR decomposition linear system solver</title>

      <titleabbrev>math.solvers.qr</titleabbrev>

      <orderedlist>
        <listitem>
          <para>The template class qrd uses QR decomposition to decompose a
          matrix and solve linear systems. The only specializations of qrd
          which must be supported are qrd&lt;scalar_f, RM&gt; and
          qrd&lt;cscalar_f, RM&gt; for any return_mechanism_type value RM . An
          implementation is permitted to prevent instantiation of qrd&lt;T,
          RM&gt; for other choices of T .</para>

          <xi:include href="code/math-solvers-qr.hpp"/>
        </listitem>

        <listitem>
          <para>[<emphasis>Note: </emphasis> Declared in <xref
          linkend="math.enum"/>, enum <type>storage_type</type> indicates the
          storage format for decomposed matrixes.
          <constant>qrd_nosaveq</constant> indicates the object does not store
          <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>Q</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>. <constant>qrd_saveq1</constant> indicates
          <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>Q</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> is stored using the same amount of space as the
          matrix m given to the constructor. <constant>qrd_saveq</constant>
          indicates the square matrix <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>Q</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> is stored using the same number of rows as
          m.]</para>
        </listitem>
      </orderedlist>

      <synopsis><emphasis role="bold">qrd</emphasis>(length_type rows, length_type columns, storage_type st) VSIP_THROW((std::bad_alloc));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>rows &gt;= columns &gt; 0 .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a qrd object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc indicating memory allocation for the returned
            qrd object failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_qrd_create_f and vsip_cqrd_create_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">rows</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of rows in the <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_qrd_getattr_f and vsip_cqrd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">columns</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of columns in the <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> matrix.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_qrd_getattr_f and vsip_cqrd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>storage_type <emphasis role="bold">qstorage</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The storage type for the <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> matrix, as specified in the
            constructor.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_qrd_getattr_f and vsip_cqrd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; bool <emphasis role="bold">decompose</emphasis>(Matrix&lt;T, Block&gt; m) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m.size(0) == this-&gt;rows() . m.size(1) ==
            this-&gt;columns() . m must have full column rank equaling
            columns() and be modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Performs a QR decomposition of m into matrices
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>R</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>. The matrix m may be overwritten.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>false if the decomposition fails because m does not have
            full column rank.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The matrix m may not be modified as long as its
            decomposition may be used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>In the decomposition, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> has this-&gt;rows() rows and
            this-&gt;columns() columns. If T is a specialization of complex,
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is unitary. Otherwise, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is orthogonal. <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>R</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an upper triangular matrix. If m has full
            rank, then <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>R</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is a nonsingular matrix. No column
            interchanges are performed. This function corresponds to VSIPL
            functions vsip_qrd_f and vsip_cqrd_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, product_side_type ps, typename Block&gt; 
const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">prodq</emphasis>(const_Matrix&lt;T, Block&gt; m) VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>A call to decompose must have occurred for this object with
            <code>this-&gt;qstorage()</code> equaling either
            <code>qrd_saveq1</code> or <code>qrd_saveq</code>. Otherwise, the
            behavior is undefined. ReturnMechanism == by_value. The number of
            rows and columns of m depends on the values of tr, ps, and
            <code>this-&gt;qstorage()</code>. For <code>this-&gt;qstorage() ==
            qrd_saveq1</code>,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an arbitrary positive length_type. For
            <code>qstorage() == qrd_saveq</code>,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows().</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The product of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and m . The actual product and its number of
            rows and columns depends on the values of tr, ps, and qstorage()
            and whether T is not or is a specialization of complex . For
            qstorage() == qrd_saveq1,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the same variable as above. For qstorage()
            == qrd_saveq,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the product fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrdprodq_f
            and vsip_cqrdprodq_f. The returned matrix’s block’s type is not
            necessarily equal to Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, product_side_type ps, typename Block0, typename Block1&gt; 
bool <emphasis role="bold">prodq</emphasis>(const_Matrix&lt;T, Block0&gt; m, Matrix&lt;T, Block1&gt; destination) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>A call to decompose must have occurred for this object with
            qstorage() equaling either qrd_saveq1 or qrd_saveq . Otherwise,
            the behavior is undefined. ReturnMechanism == by_reference .
            destination must be modifiable. m and destination must not
            overlap. The number of rows and columns of m depends on the values
            of tr, ps, and qstorage() . For qstorage() == qrd_saveq1,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an arbitrary positive length_type . For
            qstorage() == qrd_saveq,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows().</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>The number of rows and columns of destination depends on the
            values of tr, ps, and qstorage() . For qstorage() ==
            qrd_saveq1,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the same variable as above. For qstorage()
            == qrd_saveq,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>The product of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>Q</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and m is stored in destination . The actual
            product depends on the values of tr and whether T is not or is a
            specialization of complex:</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>Q</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>Q</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the product succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrdprodq_f
            and vsip_cqrdprodq_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, typename Block&gt; const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">rsol</emphasis>(const_Matrix&lt;T, Block&gt; b, T const alpha) VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b.size(0) == this-&gt;columns() . A call to decompose for
            this object must have occurred. ReturnMechanism ==
            by_value.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A constant matrix m containing the solution. If tr ==
            mat_trans and T is not a specialization of complex, then
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>R</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mi>alpha</m:mi>

                      <m:mo>*</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved. If tr == mat_herm and T is a
            specialization of complex, then <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>R</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mi>alpha</m:mi>

                      <m:mo>*</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved. Otherwise, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>R</m:mi>

                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mi>alpha</m:mi>

                      <m:mo>*</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m and b are element-conformant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the algorithm could not be
            computed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrdsolr_f
            and vsip_cqrdsolr_f. The returned matrix’s block’s type is not
            necessarily equal to Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, typename Block0, typename Block1&gt;
bool <emphasis role="bold">rsol</emphasis>(const_Matrix&lt;T, Block0&gt; b, T const alpha, Matrix&lt;T, Block1&gt; destination) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b.size(0) == this-&gt;columns() . A call to decompose for
            this object must have occurred. ReturnMechanism == by_reference.
            destination must be modifiable and element conformant with b . b
            and destination must not overlap.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Stores the solution in destination . If tr == mat_trans and
            T is not a specialization of complex, then <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>R</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mtext>destination</m:mtext>

                      <m:mo>=</m:mo>

                      <m:mtext>alpha</m:mtext>

                      <m:mo>*</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved. If tr == mat_herm and T is a
            specialization of complex, then <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>R</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mtext>destination</m:mtext>

                      <m:mo>=</m:mo>

                      <m:mtext>alpha</m:mtext>

                      <m:mo>*</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved. Otherwise, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>R</m:mi>

                      <m:mtext>destination</m:mtext>

                      <m:mo>=</m:mo>

                      <m:mtext>alpha</m:mtext>

                      <m:mo>*</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the algorithm can be computed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrdsolr_f
            and vsip_cqrdsolr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; 
const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">covsol</emphasis>(const_Matrix&lt;T, Block&gt; b) VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>b.size(0) == this-&gt;columns()</code> .
            ReturnMechanism == by_value .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A matrix m containing the solution. If T is not a
            specialization of complex, then <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi>A</m:mi>

                        <m:mi>T</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mn>m</m:mn>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> is solved, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>A</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the matrix given to the most recent call to
            decompose to this object. If T is a specialization of complex,
            then <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:mrow>
                      <m:msup>
                        <m:mi>A</m:mi>

                        <m:mi>H</m:mi>
                      </m:msup>

                      <m:mo>⁢</m:mo>

                      <m:mi>A</m:mi>

                      <m:mo>⁢</m:mo>

                      <m:mn>m</m:mn>
                    </m:mrow>

                    <m:mo>=</m:mo>

                    <m:mi>b</m:mi>
                  </m:mrow>
                </m:math>
              </inlineequation> is solved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m and b are element-conformant.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the algorithm fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrsol_f
            and vsip_cqrsol_f. The returned matrix’s block’s type is not
            necessarily equal to Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block0, typename Block1&gt; 
bool <emphasis role="bold">covsol</emphasis>(const_Matrix&lt;T, Block0&gt; b,Matrix&lt;T, Block1&gt; destination) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>b.size(0) == this-&gt;columns()</code> .
            ReturnMechanism == by_reference . destination is modifiable and is
            element conformant with b . b and destination must not
            overlap.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>The solution is stored in destination . If T is not a
            specialization of complex, then <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>A</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mi>A</m:mi>

                      <m:mtext>destination</m:mtext>

                      <m:mo>=</m:mo>

                      <m:mi>b</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>A</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the matrix given to the most recent call to
            decompose for this object. If T is a specialization of complex,
            then <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>A</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mi>A</m:mi>

                      <m:mtext>destination</m:mtext>

                      <m:mo>=</m:mo>

                      <m:mtext>b</m:mtext>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is solved.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the algorithm succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrsol_f
            and vsip_cqrsol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; 
const_Matrix&lt;T,<emphasis>unspecified</emphasis>&gt; <emphasis role="bold">lsqsol</emphasis>(const_Matrix&lt;T, Block&gt; b) VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>b.size(0) == rows() . ReturnMechanism == by_value .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A constant matrix m containing the solution to the linear
            least squares problem <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:msub>
                      <m:mo>min</m:mo>

                      <m:mi>m</m:mi>
                    </m:msub>

                    <m:mo>⁡</m:mo>

                    <m:msub>
                      <m:mrow>
                        <m:mo>||</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mi>A</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:mi>m</m:mi>
                          </m:mrow>

                          <m:mo>-</m:mo>

                          <m:mi>b</m:mi>
                        </m:mrow>

                        <m:mo>||</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation>, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>A</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the matrix given to the most recent call to
            decompose for this object.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>m.size(0) == this-&gt;columns() .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the algorithm fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrsol_f
            and vsip_cqrsol_f. The returned matrix’s block’s type is not
            necessarily equal to Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block0, typename Block1&gt; 
bool <emphasis role="bold">lsqsol</emphasis>(const_Matrix&lt;T, Block0&gt; b, Matrix&lt;T, Block1&gt; destination) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>b.size(0) == this-&gt;rows()</code> .
            <code>destination.size(0) == this-&gt;columns()</code>.
            ReturnMechanism == by_reference. b and destination must not
            overlap.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Stores the solution to the linear least squares problem
            <inlineequation>
                <m:math>
                  <m:mrow>
                    <m:msub>
                      <m:mo>min</m:mo>

                      <m:mi>destination</m:mi>
                    </m:msub>

                    <m:mo>⁡</m:mo>

                    <m:msub>
                      <m:mrow>
                        <m:mo>||</m:mo>

                        <m:mrow>
                          <m:mrow>
                            <m:mi>A</m:mi>

                            <m:mo>⁢</m:mo>

                            <m:mi>destination</m:mi>
                          </m:mrow>

                          <m:mo>-</m:mo>

                          <m:mi>b</m:mi>
                        </m:mrow>

                        <m:mo>||</m:mo>
                      </m:mrow>

                      <m:mi>2</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:math>
              </inlineequation>, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>A</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the matrix given to the most recent call to
            decompose for this object, in destination .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the algorithm succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_qrsol_f
            and vsip_cqrsol_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>

    <section xml:id="math.solvers.svd">
      <title>Singular-value decomposition</title>

      <titleabbrev>math.solvers.svd</titleabbrev>

      <orderedlist>
        <listitem>
          <para>The template class svd uses singular-value decomposition to
          decompose a matrix into orthogonal or unitary matrixes and singular
          values. The only specializations of svd which must be supported are
          svd&lt;scalar_f, RM&gt; and svd&lt;cscalar_f, RM&gt; for any
          return_mechanism_type value of RM . An implementation is permitted
          to prevent instantiation of svd&lt;T, RM&gt; for other choices of T
          .</para>

          <xi:include href="code/math-solvers-svd.hpp"/>
        </listitem>

        <listitem>
          <para>Given an <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>m</m:mi>

                    <m:mo>×</m:mo>

                    <m:mi>n</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> matrix <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>A</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> to decompose, let <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>p</m:mi>

                    <m:mo>=</m:mo>

                    <m:mo>min</m:mo>

                    <m:mo stretchy="false">(</m:mo>

                    <m:mi>m</m:mi>

                    <m:mo>,</m:mo>

                    <m:mi>n</m:mi>

                    <m:mo stretchy="false">)</m:mo>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation>.</para>

          <para>[<emphasis>Note: </emphasis> Declared in <xref
          linkend="math.enum"/>, enum storage_type indicates the storage
          format for decomposed matrixes. svd_uvnos indicates the matrix is
          not stored. svd_uvpart indicates the first <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>p</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> columns of <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>U</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> or the first <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:mi>p</m:mi>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> rows of <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:msup>
                      <m:mrow>
                        <m:mi>V</m:mi>
                      </m:mrow>

                      <m:mrow>
                        <m:mi>T</m:mi>
                      </m:mrow>
                    </m:msup>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> or <inlineequation>
              <m:math>
                <m:mstyle displaystyle="true">
                  <m:mrow>
                    <m:msup>
                      <m:mrow>
                        <m:mi>V</m:mi>
                      </m:mrow>

                      <m:mrow>
                        <m:mi>H</m:mi>
                      </m:mrow>
                    </m:msup>
                  </m:mrow>
                </m:mstyle>
              </m:math>
            </inlineequation> are stored. svd_uvfull indicates the entire
          matrix is stored. ]</para>
        </listitem>
      </orderedlist>

      <synopsis><emphasis role="bold">svd</emphasis>(length_type rows, length_type columns, storage_type ustorage, storage_type vstorage)
  VSIP_THROW((std::bad_alloc));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>Positive rows . Positive columns .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Constructs a svd object that will decompose rows by columns
            matrices.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc indicating memory allocation for the returned
            svd object failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This functional corresponds to VSIPL functions
            vsip_svd_create_f or vsip_csvd_create_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">rows</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of rows in a matrix to decompose.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_svd_getattr_f and vsip_csvd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>length_type <emphasis role="bold">columns</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The number of columns in a matrix to decompose.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_svd_getattr_f and vsip_csvd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>storage_type <emphasis role="bold">ustorage</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>How the decomposition matrix <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> should be stored by this object, if at
            all.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_svd_getattr_f and vsip_csvd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>storage_type <emphasis role="bold">vstorage</emphasis>() const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>How the decomposition matrix <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>V</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> or <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>V</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> should be stored by this object, if at
            all.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions
            vsip_svd_getattr_f and vsip_csvd_getattr_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt;
const_Vector&lt;scalar_f, <emphasis>unspecified</emphasis>&gt; <emphasis
          role="bold">
decompose</emphasis>(Matrix&lt;T, Block&gt; m) VSIP_THROW((std::bad_alloc, computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m.size(0) == this-&gt;rows() . m.size(1) ==
            this-&gt;columns() . ReturnMechanism == by_value . m must be
            modifiable.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Performs a singular-value decomposition of m . If T is not a
            specialization of complex, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mrow>
                        <m:mi>U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>S</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:msup>
                          <m:mi>V</m:mi>

                          <m:mi>H</m:mi>
                        </m:msup>
                      </m:mrow>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, where square orthogonal matrix
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> has the same number of rows as m,
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is a matrix with the same shape as m and all
            zero values except its first <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> diagonal elements are real, nonincreasing,
            nonnegative values, and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is a square orthogonal matrix with the same
            number of columns as m . If T is a specialization of complex,
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mrow>
                        <m:mi>U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>S</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:msup>
                          <m:mi>V</m:mi>

                          <m:mi>H</m:mi>
                        </m:msup>
                      </m:mrow>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> are similar to those described above except
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> are unitary, not orthogonal, matrices. If
            ustorage() == svd_uvnos, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is not stored. If ustorage() == svd_uvpart,
            the first <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> columns of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> are stored. If ustorage() == svd_uvfull, all
            columns are stored. <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>V</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> or <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>V</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, depending on whether T is not or is a
            specialization of complex, respectively, is similarly
            stored.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A const_Vector with length_type <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> containing the singular values of m in
            nonincreasing order.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The matrix m may not be modified as long as its
            decomposition may be used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>std::bad_alloc upon memory allocation, and computation_error
            if the decomposition could not be computed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>Memory may be allocated; the object’s memory requirements
            are not specified. This function corresponds to the functionality
            of VSIPL functions vsip_svd_f or vsip_csvd_f. The returned
            vector’s block’s type does not necessarily equal Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block0, typename Block1&gt; 
bool <emphasis role="bold">decompose</emphasis>(Matrix&lt;T, Block0&gt; m, Vector&lt;scalar_f, Block1&gt; destination) VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>m.size(0) == this-&gt;rows() . m.size(1) ==
            this-&gt;columns() . destination.size() == <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>. m and destination must be modifiable. m and
            destination must not overlap. ReturnMechanism ==
            by_reference.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Performs a singular-value decomposition of m . The singular
            values of m are stored in destination . If T is not a
            specialization of complex, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mrow>
                        <m:mi>U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>S</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:msup>
                          <m:mi>V</m:mi>

                          <m:mi>T</m:mi>
                        </m:msup>
                      </m:mrow>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, where square orthogonal matrix
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> has the same number of rows as m,
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is a matrix with the same shape as m and all
            zero values except its first <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> diagonal elements are real, nonincreasing,
            nonnegative values, and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is a square orthogonal matrix with the same
            number of columns as m. If T is a specialization of complex,
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>m</m:mi>

                      <m:mo>=</m:mo>

                      <m:mrow>
                        <m:mi>U</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:mi>S</m:mi>

                        <m:mo>⁢</m:mo>

                        <m:msup>
                          <m:mi>V</m:mi>

                          <m:mi>H</m:mi>
                        </m:msup>
                      </m:mrow>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>S</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> are similar to those described above except
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> are unitary, not orthogonal, matrices. If
            ustorage() == svd_uvnos, <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is not stored. If ustorage() == svd_uvpart,
            the first <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> columns of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> are stored. If ustorage() == svd_uvfull, all
            columns are stored. <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>V</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>T</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> or <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:msup>
                        <m:mrow>
                          <m:mi>V</m:mi>
                        </m:mrow>

                        <m:mrow>
                          <m:mi>H</m:mi>
                        </m:mrow>
                      </m:msup>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>, depending on whether T is not or is a
            specialization of complex, respectively, is similarly
            stored.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the decomposition succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Postconditions:</term>

          <listitem>
            <para>The matrix m may not be modified as long as its
            decomposition may be used.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to the functionality of VSIPL
            functions vsip_svd_f or vsip_csvd_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, product_side_type ps, typename Block&gt; 
const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">
produ</emphasis>(const_Matrix&lt;T, Block&gt; m) const VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>ReturnMechanism == by_value . A call to decompose must have
            occurred for this object with this-&gt;ustorage() equaling either
            svd_uvpart or svd_uvfull . The number of rows and columns of m
            depends on the values of tr, ps, and this-&gt;ustorage() . For
            this-&gt;ustorage() == svd_uvpart,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an arbitrary positive length_type . For
            this-&gt;ustorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows().</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The product of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and m . The actual product and its number of
            rows and columns depends on the values of tr, ps, and
            this-&gt;ustorage() and whether T is not or is a specialization of
            complex . For this-&gt;ustorage() == svd_uvpart,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>U</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>U</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the same variable as above. For
            this-&gt;ustorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>U</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>U</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the product fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdprodu_f
            and vsip_csvdprodu_f. The returned matrix’s block’s type does not
            necessarily equal Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, product_side_type ps, typename Block0, typename Block1&gt; 
bool <emphasis role="bold">produ</emphasis>(const_Matrix&lt;T, Block0&gt; m, Matrix&lt;T, Block1&gt; destination) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>ReturnMechanism == by_reference</code>.
            <parameter>m</parameter> and <parameter>destination</parameter>
            must not overlap. A call to <function>decompose</function> must
            have occurred for this object with<code>
            this-&gt;ustorage()</code> equaling either
            <constant>svd_uvpart</constant> or <constant>svd_uvfull</constant>
            . The number of rows and columns of m depends on the values of
            <parameter>tr</parameter>, <parameter>ps</parameter>, and
            <code>this-&gt;ustorage()</code> . For <code>ustorage() ==
            svd_uvpart</code>,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an arbitrary positive length_type . For
            this-&gt;ustorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows() .</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>The required number of rows and columns of destination
            depends on the values of tr, ps, and this-&gt;ustorage() . For
            this-&gt;ustorage() == svd_uvpart,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the same variable as above. For
            this-&gt;ustorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>rows(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, rows()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Stores the product of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and m in destination . The actual product
            depends on the values of tr and ps and whether T is not or is a
            specialization of complex:</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>U</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>U</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>U</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the product succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdprodu_f
            and vsip_csvdprodu_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, product_side_type ps, typename Block&gt; 
const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis role="bold">
prodv</emphasis>(const_Matrix&lt;T, Block&gt; m) const VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>ReturnMechanism == by_value</code> . A call to
            <function>decompose</function> must have occurred for this object
            with<code> this-&gt;vstorage()</code> equaling either
            <parameter>svd_uvpart</parameter> or
            <parameter>svd_uvfull</parameter> . The number of rows and columns
            of m depends on the values of <parameter>tr</parameter>,
            <parameter>ps</parameter>, and <code>this-&gt;vstorage()</code> .
            For <code>this-&gt;vstorage() == svd_uvpart</code>,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an arbitrary positive length_type . For
            this-&gt;vstorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns() .</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>The product of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and m . The actual product and its number of
            rows and columns depends on the values of tr, T, ps, and
            this-&gt;vstorage() . For this-&gt;vstorage() ==
            svd_uvpart,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>V</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>V</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the same variable as above. For
            this-&gt;vstorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>V</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>V</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m, columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the product fails.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdprodv_f
            and vsip_csvdprodv_f. The returned matrix’s block’s type does not
            necessarily equal Block .</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;mat_op_type tr, product_side_type ps, typename Block0, typename Block1&gt; 
bool <emphasis role="bold">prodv</emphasis>(const_Matrix&lt;T, Block0&gt; m, Matrix&lt;T, Block1&gt; destination) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para><code>ReturnMechanism == by_reference</code> . m and
            destination must not overlap. A call to decompose must have
            occurred for this object with vstorage() equaling either
            svd_uvpart or svd_uvfull . The number of rows and columns of m
            depends on the values of tr, ps, and vstorage() . For
            <code>vstorage() == svd_uvpart</code>,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is an arbitrary positive length_type . For
            vstorage() == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns() .</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>The number of rows and columns of destination depends on the
            values of tr, ps, and vstorage() . For vstorage() ==
            svd_uvpart,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>p</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>

            <para>where <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>s</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> is the same variable as above. For vstorage()
            == svd_uvfull,</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm</para></entry>

                    <entry><para>columns(), <inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>s</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>, columns()</para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Stores the product of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> and m in destination . The actual product and
            its number of rows and columns depends on the values of tr and ps
            and whether T is not or is a specialization of complex .</para>

            <informaltable colsep="0" frame="none" rowheader="firstcol"
                           rowsep="0">
              <tgroup cols="3">
                <colspec align="center" colsep="1"/>

                <thead>
                  <row rowsep="1">
                    <entry align="center"/>

                    <entry align="center">ps == mat_lside</entry>

                    <entry align="center">ps == mat_rside</entry>
                  </row>
                </thead>

                <tbody>
                  <row>
                    <entry><para>tr == mat_ntrans</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>V</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:mi>V</m:mi>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_trans, T</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>T</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>

                  <row>
                    <entry><para>tr == mat_herm,
                    complex&lt;T&gt;</para></entry>

                    <entry><para><inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation>m</para></entry>

                    <entry><para>m<inlineequation>
                        <m:math>
                          <m:mstyle displaystyle="true">
                            <m:mrow>
                              <m:msup>
                                <m:mrow>
                                  <m:mi>V</m:mi>
                                </m:mrow>

                                <m:mrow>
                                  <m:mi>H</m:mi>
                                </m:mrow>
                              </m:msup>
                            </m:mrow>
                          </m:mstyle>
                        </m:math>
                      </inlineequation></para></entry>
                  </row>
                </tbody>
              </tgroup>
            </informaltable>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if the product succeeds.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdprodv_f
            and vsip_csvdprodv_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>const_Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; 
<emphasis role="bold">u</emphasis>(index_type low, index_type high) const VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>A call to decompose must have occurred for this object with
            ustorage() equaling either svd_uvpart or svd_uvfull . 0 &lt;= low
            &lt;= high . If <code>this-&gt;ustorage() == svd_uvpart</code>,
            high &lt;= <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>. If<code> this-&gt;ustorage() ==
            svd_uvfull</code>, high &lt;= this-&gt;rows() .
            <code>ReturnMechanism == by_value</code> .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A submatrix of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> containing columns low, low+1, …, high,
            inclusive.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the most recent decomposition
            failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdmatu_f
            and vsip_csvdmatu_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; 
bool <emphasis role="bold">u</emphasis>(index_type low, index_type high, Matrix&lt;T, Block&gt; destination) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>A call to decompose must have occurred for this object
            with<code> this-&gt;ustorage()</code> equaling either svd_uvpart
            or svd_uvfull . 0 &lt;= low &lt;= high . If
            <code>this-&gt;ustorage() == svd_uvpart</code>, high &lt;=
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>. If<code> this-&gt;ustorage() ==
            svd_uvfull</code>, high &lt;= this-&gt;rows() .
            <code>destination.size(0) == this-&gt;rows()</code> .
            <code>destination.size(1) == high - low + 1</code> . destination
            must be modifiable. <code>ReturnMechanism == by_reference</code>
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Store a submatrix of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>U</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> containing columns low, low+1, …, high,
            inclusive, into destination .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if a matrix is stored.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdmatu_f
            and vsip_csvdmatu_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>Matrix&lt;T, <emphasis>unspecified</emphasis>&gt; <emphasis
          role="bold">
v</emphasis>(index_type low, index_type high) const VSIP_THROW((computation_error));</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>A call to decompose must have occurred for this object with
            <code>this-&gt;vstorage()</code> equaling either svd_uvpart or
            svd_uvfull . 0 &lt;= low &lt;= high . If <code>this-&gt;vstorage()
            == svd_uvpart</code>, high &lt;= <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>. If <code>this-&gt;vstorage() ==
            svd_uvfull</code>, high &lt;= this-&gt;columns() .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>A submatrix of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> containing columns low, low+1, …, high,
            inclusive.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Throws:</term>

          <listitem>
            <para>computation_error if the most recent decomposition
            failed.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdmatv_f
            and vsip_csvdmatv_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <synopsis>template &lt;typename Block&gt; bool <emphasis role="bold">
v</emphasis>(index_type low, index_type high, Matrix&lt;T, Block&gt; destination) const VSIP_NOTHROW;</synopsis>

      <variablelist>
        <varlistentry>
          <term>Requires:</term>

          <listitem>
            <para>A call to decompose must have occurred for this object
            with<code> this-&gt;vstorage()</code> equaling either svd_uvpart
            or svd_uvfull . 0 &lt;= low &lt;= high . If
            <code>this-&gt;vstorage() == svd_uvpart</code>, high &lt;=
            <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>p</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation>. If <code>this-&gt;vstorage() ==
            svd_uvfull</code>, high &lt;= this-&gt;columns() .
            <code>destination.size(0) == this-&gt;columns()</code> .
            <code>destination.size(1) == high - low + 1</code> . destination
            must be modifiable. <code>ReturnMechanism == by_reference</code>
            .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Effects:</term>

          <listitem>
            <para>Store a submatrix of <inlineequation>
                <m:math>
                  <m:mstyle displaystyle="true">
                    <m:mrow>
                      <m:mi>V</m:mi>
                    </m:mrow>
                  </m:mstyle>
                </m:math>
              </inlineequation> containing columns low, low+1, …, high,
            inclusive, into destination .</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Returns:</term>

          <listitem>
            <para>true if a matrix is stored.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term>Note:</term>

          <listitem>
            <para>This function corresponds to VSIPL functions vsip_svdmatv_f
            and vsip_csvdmatv_f.</para>
          </listitem>
        </varlistentry>
      </variablelist>
    </section>
  </section>
</chapter>
